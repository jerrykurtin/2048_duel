<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="styles.css">
        <title>2048 Duel</title>
    </head>
    <body>
        <div class="container">
            <div class="title-container">
                <h1 class="title">2048 Duel!</h1>
                <div class="score-row">
                    <div class="score player1-text text-left" id="player1-score">Player 1 Score -></div>
                    <div class="score player2-text text-right" id="player2-score"><- Player 2 Score</div>
                </div>
    
            </div>
            <div class="game-container">
                <div class="grid-container">
                    <div class="grid-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                    <div class="grid-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                    <div class="grid-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                    <div class="grid-row final-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                </div>
                <div class="tile-container" id="tile-container"></div>
            </div>
            <div class="below-game-container" id="below-game-container"></div>
            <div class="instructions-container">
                <p><strong>How to play:</strong> use the arrow keys to move the pieces. When the same number move into each other, the
                    pieces merge and double.</p>
                <p><strong>Multiplayer:</strong> The two players take turns. On your turn, merge one of your pieces with one of your opponents to steal the piece. The winner is the first to reach 64 or fill up the board with the 
                    highest score.</p>
                <p><strong>Credits:</strong> This game is my fresh take on <a href="https://play2048.co">2048</a>. Have fun :) ~Jerry</p>
            </div>
        </div>
        
        <script>
            // ----------------------- Settings and Setup -----------------------
            var tile_container = document.getElementById("tile-container");
            var player1_score = document.getElementById("player1-score");
            var player2_score = document.getElementById("player2-score");
            var below_game = document.getElementById("below-game-container");

            var size = 150;

            // fonts
            block_font = "75px Standard";
            block_font2 = "75px Palatino";
            block_font3 = "75px Helvetica Neue";
            

            score_font = "30px Palatino";
            turn_font = "50px Palatino";


            // colors
            var green = "121, 130, 101";
            var salmon = "203, 141, 126";
            var navy = "33, 51, 67";
            var yellow = "231,185,28"
            
            var black = "67,67,67";
            var grey = "147,152,157";
            var white = "250,250,250";
            var cream = "250,249,243";

            // settings for player 1 and 2 colors
            var p1color = green;
            var p2color = salmon;

            var rightPressed = false;
            var leftPressed = false;
            var upPressed = false;
            var downPressed = false;
            var resetPressed = false;

            // board information
            var my_board = null;
            var keypress_active = false;
            var update_needed = false;
            var move_type = null;
            var endgame = false;

            // holds the http request object
            var xhr = null;

            // holds details on touch controls
            var initialX = null;
            var initialY = null;
            var touchThreshold = 30;



            // ------------------------------------------------------------------

            // --------------------------- Game Logic ---------------------------
            class Board {
                constructor(win_condition=64) {
                    // board variables
                    this.board_size = 4;
                    this.win_condition = win_condition;
                    this.squares_added = 1;
                    this.board_state = "continue";  // "continue", "no_change", "win1", "win2", "tie"
                    this.player = 0;
                    this.first_round = true;

                    // create board
                    this.board = new Array(this.board_size);
                    for (let r = 0; r < this.board.length; ++r){
                        this.board[r] = new Array(this.board_size).fill(0);
                    }
                    this.owner = new Array(this.board_size);
                    for (let r = 0; r < this.owner.length; ++r){
                        this.owner[r] = new Array(this.board_size).fill(-1);
                    }

                    // initialize the first numbers
                    var st1 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]
                    var st2 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]
                    while (st1[0] == st2[0] || st1[1] == st2[1])
                        st2 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]

                    this.board[st1[0]][st1[1]] = 2
                    this.owner[st1[0]][st1[1]] = 0

                    this.board[st2[0]][st2[1]] = 2
                    this.owner[st2[0]][st2[1]] = 1


                    this.p1score = 2;
                    this.p2score = 2;
                }

                move(dir){
                    var prev_state = deepCopy(this.board);

                    // make the move
                    if (dir == "up")
                        this.up();
                    else if (dir == "down")
                        this.down();
                    else if (dir == "left")
                        this.left();
                    else if (dir == "right")
                        this.right();
                    else{
                        console.log("ERROR: invalid direction (" + dir + ")");
                        return;
                    }

                    // check for no change
                    if (deepCompare(this.board, prev_state)){
                        this.board_state = "no_change";
                        return;
                    }
                    else{
                        this.board_state = "continue";
                    }

                    // check for win condition and add squares
                    var cands = new Array();
                    this.p1score = 0;
                    this.p2score = 0;
                    for (let row = 0; row < this.board.length; ++row){
                        for (let col = 0; col < this.board[0].length; ++col){

                            // win!
                            if (this.board[row][col] == this.win_condition){
                                if (this.owner[row][col] == 0){
                                    this.board_state = "win1";
                                }
                                else{
                                    this.board_state = "win2";
                                }
                                return;
                            }

                            // empty square
                            else if (this.board[row][col] == 0){
                                cands.push([row, col]);
                            }

                            // number square, add to score
                            else {
                                if (this.owner[row][col] == 0)
                                    this.p1score += this.board[row][col];
                                else
                                    this.p2score += this.board[row][col];
                            }
                        }
                    }

                    // elimination win
                    if (this.p1score == 0){
                        this.board_state = "win1";
                        return;
                    }
                    else if (this.p2score == 0){
                        this.board_state = "win2";
                        return;
                    }

                    // select new value(s) to add
                    var new_squares = new Array();
                    if (this.first_round && this.squares_added == 1){
                        new_squares.push(4);
                        this.first_round = false;
                    }
                    else{
                        var choices = new Array();
                        for (let twos = 0; twos < 75; ++twos)
                            choices.push(2);
                        for (let fours = 0; fours < 24; ++fours)
                            choices.push(4);
                        for (let eights = 0; eights < 1; ++eights)
                            choices.push(8);
                        
                        for (let ch = 0; ch < this.squares_added; ++ch)
                            new_squares.push(choices[randint(0, choices.length - 1)]);
                    }

                    // add the new value(s) to random location(s)
                    var locations = new Array();
                    for (let ch = 0; ch < this.squares_added; ++ch)
                        locations.push(cands[randint(0, cands.length - 1)]);

                    for (let square = 0; square < new_squares.length; ++square){
                        this.board[locations[square][0]][locations[square][1]] = new_squares[square];
                        this.owner[locations[square][0]][locations[square][1]] = this.player;

                        if (this.player == 0)
                            this.p1score += new_squares[square];
                        else
                            this.p2score += new_squares[square];
                    }
                    
                    // switch to the next player
                    this.player = (this.player + 1) % 2;
                    
                    // TODO: change endgame for multiple squares added
                    // endgame: grid is full
                    if (cands.length <= this.squares_added){
                        if (this.p1score > this.p2score)
                            this.board_state = "win1";
                        else if (this.p1score < this.p2score)
                            this.board_state = "win2";
                        else
                            this.board_state = "tie";
                    }
                    return;
                }
                
                left(){
                    /* make a left movement */
                    for (let row = 0; row < this.board.length; ++row){
                        // store the new row
                        var newrow = Array(this.board.length).fill(0);
                        var newowner = Array(this.board.length).fill(-1);
                        var newidx = 0;

                        for (let col = 0; col < this.board[0].length; ++col){
                            if (this.board[row][col] != 0){

                                // merge
                                if (newidx > 0 && this.board[row][col] == newrow[newidx - 1]){
                                    newrow[newidx - 1] = newrow[newidx - 1] * -2; // negative prevents double merging

                                    // determine ownership of square
                                    if (newowner[newidx - 1] != this.owner[row][col]){
                                        newowner[newidx - 1] = this.player;
                                    }
                                }

                                // move without merging
                                else{
                                    newrow[newidx] = this.board[row][col];
                                    newowner[newidx] = this.owner[row][col];
                                    newidx += 1;
                                }
                            }
                        }

                        // update the board
                        for (let col = 0; col < this.board[0].length; ++col)
                            newrow[col] = Math.abs(newrow[col]);
                        this.board[row] = newrow;

                        // update the owner
                        this.owner[row] = newowner;
                    }
                }

                up(){
                    /* make an up movement */
                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    this.left();

                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);
                }

                right(){
                    /* make a right movement */
                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    this.left();

                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);

                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);
                }

                down(){
                    /* make a downward movement */
                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);

                    this.left();

                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);
                }
            }

            // helper functions ---------------------------
            function randint(min, max){
                /* random number between min and max, inclusive */
                return Math.floor(Math.random() * (max - min + 1) ) + min;
            }

            const deepCopy = (arr) => {
                /* deep copy a multi-dimensional array */
                let copy = [];
                arr.forEach(elem => {
                    if(Array.isArray(elem)){
                    copy.push(deepCopy(elem))
                    }else{
                    if (typeof elem === 'object') {
                        copy.push(deepCopyObject(elem))
                    } else {
                        copy.push(elem)
                    }
                    }
                })
                return copy;
            }

            function deepCompare(arr1, arr2){
                /* determines equality between two arrays */
                if (arr1.length != arr2.length || arr1[0].length != arr2[0].length)
                    return false;

                for (let r = 0; r < arr1.length; ++r){
                    for (let c = 0; c < arr1[0].length; ++c){
                        if (arr1[r][c] != arr2[r][c])
                            return false;
                    }
                }

                return true;
            }

            function rotateCounter(arr){
                /* rotate a square array 90 degrees counterclockwise */
                newarr = deepCopy(arr);

                for (let row = 0; row < arr.length; ++row){
                    for (let col = 0; col < arr[0].length; ++col){
                        newarr[newarr.length - col - 1][row] = arr[row][col];
                    }
                }

                return newarr;
            }

            function rotateClock(arr){
                /* rotate a square array 90 degrees clockwise */
                newarr = deepCopy(arr);

                for (let row = 0; row < arr.length; ++row){
                    for (let col = 0; col < arr[0].length; ++col){
                        newarr[col][arr.length - row - 1] = arr[row][col];
                    }
                }

                return newarr
            }

            // debug
            var my_board = new Board(64);

            // ------------------------------------------------------------------

            // --------------------- Listeners and Handlers ---------------------
            document.addEventListener("keydown", keyDownHandler, false);
            document.addEventListener("keyup", keyUpHandler, false);
            document.addEventListener("touchstart", touchstartHandler, false);
            document.addEventListener("touchmove", touchmoveHandler, false);
            document.addEventListener("touchend", touchendHandler, false);

            function keyDownHandler(e) {
                // prevent arrow keys from scrolling
                if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                    e.preventDefault();
                }   

                if(e.key == "Right" || e.key == "ArrowRight" || e.key == "d" || e.key == "KeyD") {
                    rightPressed = true;
                    move_type = "right";
                }
                else if(e.key == "Left" || e.key == "ArrowLeft" || e.key == "a" || e.key == "KeyA") {
                    leftPressed = true;
                    move_type = "left";
                }
                else if (e.key == "Up" || e.key == "ArrowUp" || e.key == "w" || e.key == "KeyW"){
                    upPressed = true;
                    move_type = "up";
                }
                else if (e.key == "Down" || e.key == "ArrowDown" || e.key == "s" || e.key == "KeyS"){
                    downPressed = true;
                    move_type = "down";
                }

                else if (e.key == "r" || e.key == "KeyR"){
                    resetPressed = true;
                }

                // set keypress active variable
                if (rightPressed || leftPressed || upPressed || downPressed || resetPressed){
                    if (!keypress_active){
                        keypress_active = true;
                        update_needed = true;
                    }
                }
            }

            function keyUpHandler(e) {
                if(e.key == "Right" || e.key == "ArrowRight" || e.key == "d" || e.key == "KeyD") {
                    rightPressed = false;
                }
                else if(e.key == "Left" || e.key == "ArrowLeft" || e.key == "a" || e.key == "KeyA") {
                    leftPressed = false;
                }
                else if (e.key == "Up" || e.key == "ArrowUp" || e.key == "w" || e.key == "KeyW"){
                    upPressed = false;
                }
                else if (e.key == "Down" || e.key == "ArrowDown" || e.key == "s" || e.key == "KeyS"){
                    downPressed = false;
                }
                else if (e.key == "r" || e.key == "KeyR"){
                    resetPressed = false;
                }

                if (!rightPressed && !leftPressed && !upPressed && !downPressed && !resetPressed){
                    if (keypress_active){
                        keypress_active = false;
                    }
                }
            }

            // mobile device handlers
            function touchstartHandler(e) {
                initialX = e.touches[0].pageX;
                initialY = e.touches[0].pageY;

                keypress_active = true;
            }

            function touchmoveHandler(e) {
                let xdiff = e.touches[0].pageX - initialX;
                let ydiff = e.touches[0].pageY - initialY;

                if (keypress_active){
                    // left or right move
                    if (Math.abs(xdiff) > touchThreshold){
                        if (xdiff < 0)
                            move_type = "left";
                        else
                            move_type = "right";
                        update_needed = true;
                        keypress_active = false;
                    }
    
                    // up or down move
                    else if (Math.abs(ydiff) > touchThreshold){
                        if (ydiff < 0)
                            move_type = "up";
                        else
                            move_type = "down";
                        update_needed = true;
                        keypress_active = false;
                    }
                }
            }

            function touchendHandler(e) {
                keypress_active = false;
            }

            // ------------------------------------------------------------------
            
            // ------------------------ Game Logic ------------------------

            function makeMove(direction){
                console.log("moving in direction " + direction);
                my_board.move(direction);
                console.log("board is now ", my_board);

                // check for endgame
                console.log("board state: ", my_board.board_state);
                if (my_board.board_state != "continue" && my_board.board_state != "no_change"){
                    console.log("endgame reached");
                    endgame = true;
                }

                drawBoard();
            }

            function resetBoard(){
                my_board = new Board(64);
                console.log("board reset:", my_board);

                drawBoard();
            }

            // ------------------------------------------------------------------


            // draw the grid
            function drawBoard(board_info){
                /* update the game board */

                // clear old squares and settings
                while(tile_container.hasChildNodes()){
                    tile_container.removeChild(tile_container.firstChild);
                }
                if (below_game.classList.contains("player1-text")){
                    below_game.classList.remove("player1-text")
                }
                if (below_game.classList.contains("player2-text")){
                    below_game.classList.remove("player2-text")
                }

                // iterate through grid
                for (var row = 0; row < 4; ++row){
                    for (var col = 0; col < 4; ++col){
                        text = "0";
                        owner = null;
                        player = -1;

                        // parse the current number
                        if (my_board != null){
                            console.log("board information recieved in drawGrid()")
                            text = my_board.board[col][row].toString();                            
                            
                            // set the owner
                            if (text != 0){
                                if (my_board.owner[col][row] == 0)
                                    player = 1;
                                else 
                                    player = 2;
                            }
                        }

                        // draw new square
                        if (text != 0){
                            const newSquare = document.createElement("div");
                            var loc = "tile-position-" + (row + 1) + "-" + (col + 1);
                            console.log("adding to location " + loc);
                            newSquare.classList.add(loc);
                            tile_container.appendChild(newSquare);
                            newSquare.classList.add("tile");
                            console.log("new square created");

                            // set color
                            if (player == 1)
                                newSquare.classList.add("player1");
                            else
                                newSquare.classList.add("player2");

                            // set the text
                            newSquare.innerHTML = text;
                        }
                    }
                }

                // write the scores
                player1_score.innerHTML = "Player 1 score -> " + my_board.p1score;
                player2_score.innerHTML = my_board.p2score + " <- Player 2 score";
                // determine game state
                if (my_board.board_state == "tie"){
                    text = "It's a tie!";
                }

                else if (my_board.board_state == "win1"){
                    console.log("player 1 won!");
                    below_game.classList.add("player1-text");
                    text = "Player 1 wins!";
                }

                else if (my_board.board_state == "win2"){
                    below_game.classList.add("player1-text");
                    text = "Player 2 wins!";
                }

                // normal
                else{
                    if (my_board.player == 0){
                        below_game.classList.add("player1-text");
                        if (my_board.board_state == "no_change")
                            text = "No change, move again";
                        else
                            text = "Player 1's turn";
                    }

                    else{
                        below_game.classList.add("player2-text");
                        if (my_board.board_state == "no_change")
                            text = "No change, move again";
                        else
                            text = "Player 2's turn";
                    }
                }
                below_game.innerHTML = text;
            }

            function mainLoop(){

                // process keypress
                if (update_needed){
                    if (resetPressed){
                        console.log("resetting");
                        resetBoard();
                        endgame = false;
                    }
                    else if (!endgame){
                        console.log("making move " + move_type);
                        makeMove(move_type);
                    }
                    update_needed = false;
                }

                // debugging
                // document.getElementById("debug1").innerHTML = "up: " + upPressed + ", down: " + downPressed;
                // document.getElementById("debug2").innerHTML = "left: " + leftPressed + ", right: " + rightPressed;
            }
            
            resetBoard();
            setInterval(mainLoop, 10);
        </script>
    </body>
</html>
