<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="styles.css">
        <title>2048 Duel</title>
    </head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1J9CBQR5PG"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-1J9CBQR5PG');
    </script>
    <body>
        <div class="container">
            <div class="title-container">
                <h1 class="title">2048 Duel!</h1>
                <div class="score-row">
                    <div class="score player1-text text-left" id="player1-score">Player 1 Score -></div>
                    <div class="score player2-text text-right" id="player2-score"><- Player 2 Score</div>
                </div>
    
            </div>
            <div class="game-container" id="game-container">
                <div class="endgame-msg" id="endgame-msg"></div>
                <div class="grid-container">
                    <div class="grid-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                    <div class="grid-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                    <div class="grid-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                    <div class="grid-row final-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                </div>
                <div class="tile-container" id="tile-container"></div>
            </div>
            <div class="belowgame-container" id="below-game-container">
                <div class="turn" id="turn"></div>
                <div class="settings-container">
                    <button class="bolded" id="reset-button">Reset (r)</button>
                    <div class="dropdown">
                        <button class="dropbtn" id="gamemode-dropdown">Gamemode: Solo</button>
                        <div class="dropdown-content">
                          <button class="dropdown-element" id="gamemode-singleplayer">Solo</button>
                          <button class="dropdown-element" id="gamemode-multiplayer">Local Multiplayer</button>
                        </div>
                    </div>
                    <div class="dropdown">
                        <button class="dropbtn" id="goal-dropdown">Goal: 64</button>
                        <div class="dropdown-content">
                          <button class="dropdown-element" id="goal-32">32</button>
                          <button class="dropdown-element" id="goal-64">64</button>
                          <button class="dropdown-element" id="goal-128">128</button>
                        </div>
                    </div>
                    <div class="dropdown">
                        <button class="dropbtn" id="difficulty-dropdown">Difficulty: Easy</button>
                        <div class="dropdown-content">
                          <button class="dropdown-element" id="difficulty-easy">Easy</button>
                          <button class="dropdown-element" id="difficulty-medium">Medium</button>
                          <button class="dropdown-element" id="difficulty-hard">Hard</button>
                          <button class="dropdown-element" id="difficulty-impossible">Impossible</button>
                        </div>
                    </div>
                </div>
            </div>
            <p><strong>How to play:</strong> use the arrow keys (swipe for mobile) to move the pieces. When pieces with the same number move into each other, the
                pieces merge and double.</p>
            <p><strong>Multiplayer:</strong> The two players take turns. On your turn, merge one of your pieces with one of your opponents to steal the piece. Merging two of your own pieces or two of your opponent's doesn't change the ownership. 
                The winner is the first to create the goal piece (64) or the one with the highest score when there are no available moves.</p>
            <p><strong>Credits:</strong> This game is my fresh take on <a href="https://play2048.co">2048</a>. Have fun :) ~Jerry</p>
        </div>
        
        <script>
            // ----------------------- Settings and Setup -----------------------
            var tile_container = document.getElementById("tile-container");
            var game_container = document.getElementById("game-container");
            var player1_score = document.getElementById("player1-score");
            var player2_score = document.getElementById("player2-score");
            var turn_message = document.getElementById("turn");
            var reset_button = document.getElementById("reset-button");
            var endgame_msg = document.getElementById("endgame-msg");

            var rightPressed = false;
            var leftPressed = false;
            var upPressed = false;
            var downPressed = false;
            var resetPressed = false;
            var keypress_active = false;
            var update_needed = false;
            var move_made = false;

            // board information
            var goal = 64;
            var my_board = null;
            var move_type = null;
            var endgame = false;

            // singleplayer
            var awaiting_cpu = false;
            var singleplayer = true;
            var difficulty = "easy";    // "easy", "medium", "hard", "impossible"
            var p1name = "You";
            var p1possessive = "Your";
            var p2name = "CPU";
            var p2possessive = "CPU's";

            // holds the http request object
            var xhr = null;

            // holds details on touch controls
            var initialX = null;
            var initialY = null;
            var touchThreshold = 30;



            // ------------------------------------------------------------------

            // --------------------------- Game Logic ---------------------------
            var cardinal_moves = ["up", "down", "left", "right"];

            class Board {
                constructor(win_condition=64, copy_board=null) {
                    /**
                     * @param {int} win_condition - The number to win at. Default: 64 (ignored if copy_board is defined)
                     * @param {Board} copy_board - The board to copy, default: null
                     */

                    // board variables
                    this.board_size = 4;
                    this.win_condition = win_condition;
                    this.squares_added = 1;

                     // my workaround for a copy constructor
                     if (copy_board){
                        this.board = deepCopy(copy_board.board);
                        this.owner = deepCopy(copy_board.owner);
                        this.p1score = copy_board.p1score;
                        this.p2score = copy_board.p2score;
                        this.win_condition = copy_board.win_condition;

                        this.board_state = copy_board.board_state;
                        this.player = copy_board.player;
                        this.first_round = copy_board.first_round;

                        return;
                     }


                    this.board_state = "continue";  // "continue", "no_change", "win1", "win2", "tie"
                    this.player = 0;
                    this.first_round = true;

                    // create board
                    this.board = new Array(this.board_size);
                    for (let r = 0; r < this.board.length; ++r){
                        this.board[r] = new Array(this.board_size).fill(0);
                    }
                    this.owner = new Array(this.board_size);
                    for (let r = 0; r < this.owner.length; ++r){
                        this.owner[r] = new Array(this.board_size).fill(-1);
                    }

                    // initialize the first numbers
                    var st1 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]
                    var st2 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]
                    while (st1[0] == st2[0] || st1[1] == st2[1])
                        st2 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]

                    this.board[st1[0]][st1[1]] = 2
                    this.owner[st1[0]][st1[1]] = 0

                    this.board[st2[0]][st2[1]] = 2
                    this.owner[st2[0]][st2[1]] = 1


                    this.p1score = 2;
                    this.p2score = 2;
                }

                move(dir, add_squares=true){
                    if (this.board_state != "continue" && this.board_state != "no_change"){
                        console.log("ERROR: cannot move in endgame!");
                        return;
                    }
                    var prev_state = deepCopy(this.board);

                    // make the move
                    if (dir == "up")
                        this.up();
                    else if (dir == "down")
                        this.down();
                    else if (dir == "left")
                        this.left();
                    else if (dir == "right")
                        this.right();
                    else{
                        console.log("ERROR: invalid direction (" + dir + ")");
                        return;
                    }

                    // check for no change
                    if (deepCompare(this.board, prev_state)){
                        this.board_state = "no_change";
                        return;
                    }
                    else{
                        this.board_state = "continue";
                    }

                    // check for win condition and add squares
                    var cands = new Array();
                    this.p1score = 0;
                    this.p2score = 0;
                    for (let row = 0; row < this.board.length; ++row){
                        for (let col = 0; col < this.board[0].length; ++col){

                            // win!
                            if (this.board[row][col] == this.win_condition){
                                if (this.owner[row][col] == 0){
                                    this.board_state = "win1";
                                }
                                else{
                                    this.board_state = "win2";
                                }
                            }

                            // empty square
                            else if (this.board[row][col] == 0){
                                cands.push([row, col]);
                            }

                            // number square, add to score
                            else {
                                if (this.owner[row][col] == 0)
                                    this.p1score += this.board[row][col];
                                else
                                    this.p2score += this.board[row][col];
                            }
                        }
                    }

                    // elimination win
                    if (this.p1score == 0 || this.board_state == "win2"){
                        this.board_state = "win2";
                        return;
                    }
                    else if (this.p2score == 0 || this.board_state == "win1"){
                        this.board_state = "win1";
                        return;
                    }

                    // endgame: grid is full
                    if (!this.move_exists() || cands.length < this.squares_added){
                        if (this.p1score > this.p2score)
                            this.board_state = "win1";
                        else if (this.p1score < this.p2score)
                            this.board_state = "win2";
                        else
                            this.board_state = "tie";
                        return;
                    }

                    // add squares
                    if (add_squares){
                        // select new value(s) to add
                        var new_squares = new Array();
                        if (this.first_round && this.squares_added == 1){
                            new_squares.push(4);
                            this.first_round = false;
                        }
                        else{
                            var choices = new Array();
                            for (let twos = 0; twos < 75; ++twos)
                            choices.push(2);
                            for (let fours = 0; fours < 24; ++fours)
                            choices.push(4);
                            for (let eights = 0; eights < 1; ++eights)
                            choices.push(8);
                            
                            for (let ch = 0; ch < this.squares_added; ++ch)
                            new_squares.push(choices[randint(0, choices.length - 1)]);
                        }
                        
                        // add the new value(s) to random location(s)
                        var locations = new Array();
                        for (let ch = 0; ch < this.squares_added; ++ch)
                        locations.push(cands[randint(0, cands.length - 1)]);
                        
                        for (let square = 0; square < new_squares.length; ++square){
                            this.board[locations[square][0]][locations[square][1]] = new_squares[square];
                            this.owner[locations[square][0]][locations[square][1]] = this.player;
                            
                            if (this.player == 0)
                            this.p1score += new_squares[square];
                            else
                            this.p2score += new_squares[square];
                        }
                    }
                        
                    // switch to the next player
                    this.player = (this.player + 1) % 2;
                }

                move_exists(){
                    /* Test if available move exists */
                    var temp_board = new Board(-1, this);
                    var prev_state = temp_board.board;
                    
                    temp_board.up();
                    if (!deepCompare(prev_state, temp_board.board))
                        return true;
                    temp_board.down();
                    if (!deepCompare(prev_state, temp_board.board))
                        return true;
                    temp_board.left();
                    if (!deepCompare(prev_state, temp_board.board))
                        return true;
                    temp_board.right();
                    if (!deepCompare(prev_state, temp_board.board))
                        return true;

                    return false;
                }
                
                left(){
                    /* make a left movement */
                    for (let row = 0; row < this.board.length; ++row){
                        // store the new row
                        var newrow = Array(this.board.length).fill(0);
                        var newowner = Array(this.board.length).fill(-1);
                        var newidx = 0;

                        for (let col = 0; col < this.board[0].length; ++col){
                            if (this.board[row][col] != 0){

                                // merge
                                if (newidx > 0 && this.board[row][col] == newrow[newidx - 1]){
                                    newrow[newidx - 1] = newrow[newidx - 1] * -2; // negative prevents double merging

                                    // determine ownership of square
                                    if (newowner[newidx - 1] != this.owner[row][col]){
                                        newowner[newidx - 1] = this.player;
                                    }
                                }

                                // move without merging
                                else{
                                    newrow[newidx] = this.board[row][col];
                                    newowner[newidx] = this.owner[row][col];
                                    newidx += 1;
                                }
                            }
                        }

                        // update the board
                        for (let col = 0; col < this.board[0].length; ++col)
                            newrow[col] = Math.abs(newrow[col]);
                        this.board[row] = newrow;

                        // update the owner
                        this.owner[row] = newowner;
                    }
                }

                up(){
                    /* make an up movement */
                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    this.left();

                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);
                }

                right(){
                    /* make a right movement */
                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    this.left();

                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);

                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);
                }

                down(){
                    /* make a downward movement */
                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);

                    this.left();

                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);
                }

                find_move_value(){
                    /* finds the maximum and minimum next-turn move values for a board (p1score - p2score) */
                    // TO-DO: add depth argument for recursion

                    var scores = [];
                    for (let dir = 0; dir < 4; ++dir){
                        var temp_board = new Board(-1, this);
                        temp_board.move(cardinal_moves[dir], false);
                        if (temp_board.board_state == "no_change")
                            continue;
                        else 
                            scores.push(temp_board.p1score - temp_board.p2score);
                    }

                    if (!scores){
                        return null;
                    }

                    return [Math.min(...scores), Math.max(...scores)];
                }

                explore_moves() {
                    /* const function to explore the best moves. Returns the moves in order of their average 2-turn payout */
                    var dirs = [[0, cardinal_moves[0]], [0, cardinal_moves[1]], [0, cardinal_moves[2]], [0, cardinal_moves[3]]];
                    var player = this.player;
                    var initial_diff = this.p1score - this.p2score;
                    console.log("received board:\n" + this.build_grid() + " as player " + player);

                    // search the moves in every direction
                    for (let dir = 0; dir < 4; ++dir){
                        var temp_board = new Board(-1, this);
                        temp_board.move(cardinal_moves[dir], false);
                        var move_diff = temp_board.p1score - temp_board.p2score - initial_diff;

                        console.log("exploring move " + cardinal_moves[dir] + ", has board\n" + temp_board.build_grid() + "\n, diff " + move_diff + ", and state " + temp_board.board_state + " and win condition " + temp_board.win_condition);

                        // don't promote no_change
                        if (temp_board.board_state == "no_change"){
                            dirs[dir][0] = -Number.MAX_VALUE;
                        }

                        // promote win, don't promote loss
                        else if (temp_board.board_state == "win1"){
                            if (player == 0)
                                dirs[dir][0] = Number.MAX_VALUE;
                            else
                                dirs[dir][0] = -Number.MAX_VALUE;
                        }
                        else if (temp_board.board_state == "win2"){
                            if (player == 1)
                                dirs[dir][0] = Number.MAX_VALUE;
                            else
                                dirs[dir][0] = -Number.MAX_VALUE;
                        }

                        // calculate the best next move
                        else{
                            let min_max = temp_board.find_move_value();
                            if (player == 0)
                                var added = min_max[0];
                            else
                                var added = min_max[1];
                            dirs[dir][0] =  added + move_diff;
                            if (player == 1){
                                dirs[dir][0] = -1 * dirs[dir][0];
                            }
                        }
                    }

                    // sorts in reverse order
                    dirs.sort(function(a,b){return b[0] - a[0]})
                    // remove all -infinity values
                    while (dirs[dirs.length - 1][0] == -Number.MAX_VALUE)
                        dirs.pop();
                    return dirs;
                }

                build_grid(){
                    var board = deepCopy(this.board);
                    for (let r = 0; r < board.length; ++r){
                        for (let c = 0; c < board[0].length; ++c){
                            if (this.owner[r][c] == 1)
                                board[r][c] *= -1;
                        }
                    }

                    var ans = "";
                    for (let row = 0; row < board.length; ++row){
                        for (let col = 0; col < board[0].length; ++col){
                            ans += board[row][col] + "\t";
                        }
                        ans += "\n";
                    }

                    return ans;
                }
            }

            // helper functions ---------------------------
            function randint(min, max){
                /* random number between min and max, inclusive */
                return Math.floor(Math.random() * (max - min + 1) ) + min;
            }

            function randchoice(arr){
                let idx = randint(0, arr.length - 1);
                return arr[idx];
            }

            const deepCopy = (arr) => {
                /* deep copy a multi-dimensional array */
                let copy = [];
                arr.forEach(elem => {
                    if(Array.isArray(elem)){
                    copy.push(deepCopy(elem))
                    }else{
                    if (typeof elem === 'object') {
                        copy.push(deepCopyObject(elem))
                    } else {
                        copy.push(elem)
                    }
                    }
                })
                return copy;
            }

            function deepCompare(arr1, arr2){
                /* determines equality between two arrays */
                if (arr1.length != arr2.length || arr1[0].length != arr2[0].length)
                    return false;

                for (let r = 0; r < arr1.length; ++r){
                    for (let c = 0; c < arr1[0].length; ++c){
                        if (arr1[r][c] != arr2[r][c])
                            return false;
                    }
                }

                return true;
            }

            function rotateCounter(arr){
                /* rotate a square array 90 degrees counterclockwise */
                newarr = deepCopy(arr);

                for (let row = 0; row < arr.length; ++row){
                    for (let col = 0; col < arr[0].length; ++col){
                        newarr[newarr.length - col - 1][row] = arr[row][col];
                    }
                }

                return newarr;
            }

            function rotateClock(arr){
                /* rotate a square array 90 degrees clockwise */
                newarr = deepCopy(arr);

                for (let row = 0; row < arr.length; ++row){
                    for (let col = 0; col < arr[0].length; ++col){
                        newarr[col][arr.length - row - 1] = arr[row][col];
                    }
                }

                return newarr
            }

            function selectrand(options, weight) {
                /* select from array with given weights */
                var choices = new Array();
                for (let idx = 0; idx < options.length; ++idx){
                    for (let count = 0; count < weight[idx]; ++count){
                        choices.push(options[idx]);
                    }
                }

                return randchoice(choices);
            }

            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // ------------------------------------------------------------------

            // --------------------- Listeners and Handlers ---------------------
            document.addEventListener("keydown", keyDownHandler, false);
            document.addEventListener("keyup", keyUpHandler, false);
            document.addEventListener("touchstart", touchstartHandler, false);
            document.addEventListener("touchmove", touchmoveHandler, false);
            document.addEventListener("touchend", touchendHandler, false);

            // reset button
            reset_button.addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
            }, false);

            // set gamemode
            document.getElementById("gamemode-singleplayer").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                singleplayer = true;
                p1name = "You";
                p1possessive = "Yours";
                p2name = "CPU";
                p2possessive = "CPU's";
                document.getElementById("difficulty-dropdown").style.display = "inherit";
                document.getElementById("difficulty-dropdown").style.visibility = "visible";
                document.getElementById("gamemode-dropdown").innerHTML = "Gamemode: Solo";
            }, false);
            document.getElementById("gamemode-multiplayer").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                singleplayer = false;
                p1name = "Player 1";
                p1possessive = "Player 1's";
                p2name = "Player 2";
                p2possessive = "Player 2's";
                document.getElementById("difficulty-dropdown").style.display = "none";
                document.getElementById("difficulty-dropdown").style.visibility = "hidden";
                document.getElementById("gamemode-dropdown").innerHTML = "Gamemode: Local Multiplayer";
            }, false);

            // set the target
            document.getElementById("goal-32").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                goal = 32;
                document.getElementById("goal-dropdown").innerHTML = "Goal: 32";
            }, false);
            document.getElementById("goal-64").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                goal = 64;
                document.getElementById("goal-dropdown").innerHTML = "Goal: 64";
            }, false);
            document.getElementById("goal-128").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                goal = 128;
                document.getElementById("goal-dropdown").innerHTML = "Goal: 128";
            }, false);


            // set the difficulty
            document.getElementById("difficulty-easy").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                difficulty = "easy";
                document.getElementById("difficulty-dropdown").innerHTML = "Difficulty: Easy";
            }, false);
            document.getElementById("difficulty-medium").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                difficulty = "medium";
                document.getElementById("difficulty-dropdown").innerHTML = "Difficulty: Medium";
            }, false);
            document.getElementById("difficulty-hard").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                difficulty = "hard";
                document.getElementById("difficulty-dropdown").innerHTML = "Difficulty: Hard";
            }, false);
            document.getElementById("difficulty-impossible").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                difficulty = "impossible";
                document.getElementById("difficulty-dropdown").innerHTML = "Difficulty: Impossible";
            }, false);

            function keyDownHandler(e) {

                // prevent arrow keys from scrolling
                if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                    e.preventDefault();
                }   

                if (!awaiting_cpu){
                    if(e.key == "Right" || e.key == "ArrowRight" || e.key == "d" || e.key == "KeyD") {
                        rightPressed = true;
                        move_type = "right";
                    }
                    else if(e.key == "Left" || e.key == "ArrowLeft" || e.key == "a" || e.key == "KeyA") {
                        leftPressed = true;
                        move_type = "left";
                    }
                    else if (e.key == "Up" || e.key == "ArrowUp" || e.key == "w" || e.key == "KeyW"){
                        upPressed = true;
                        move_type = "up";
                    }
                    else if (e.key == "Down" || e.key == "ArrowDown" || e.key == "s" || e.key == "KeyS"){
                        downPressed = true;
                        move_type = "down";
                    }
                }

                if (e.key == "r" || e.key == "KeyR"){
                    resetPressed = true;
                }

                // set keypress active variable
                if (rightPressed || leftPressed || upPressed || downPressed || resetPressed){
                    if (!keypress_active){
                        keypress_active = true;
                        update_needed = true;
                        move_made = true;
                    }
                }
            }

            function keyUpHandler(e) {
                if(e.key == "Right" || e.key == "ArrowRight" || e.key == "d" || e.key == "KeyD") {
                    rightPressed = false;
                }
                else if(e.key == "Left" || e.key == "ArrowLeft" || e.key == "a" || e.key == "KeyA") {
                    leftPressed = false;
                }
                else if (e.key == "Up" || e.key == "ArrowUp" || e.key == "w" || e.key == "KeyW"){
                    upPressed = false;
                }
                else if (e.key == "Down" || e.key == "ArrowDown" || e.key == "s" || e.key == "KeyS"){
                    downPressed = false;
                }
                else if (e.key == "r" || e.key == "KeyR"){
                    resetPressed = false;
                }

                if (!rightPressed && !leftPressed && !upPressed && !downPressed && !resetPressed){
                    if (keypress_active){
                        keypress_active = false;
                    }
                }
            }
        
            
            // mobile device handlers
            function touchstartHandler(e) {
                initialX = e.touches[0].pageX;
                initialY = e.touches[0].pageY;
                
                // only allow swipes that start inside the game board
                // temp fix: don't check against right border
                let position = game_container.getBoundingClientRect();
                if (initialX > position.left && initialY > position.top && initialY < position.bottom)
                    keypress_active = true;
            }

            function touchmoveHandler(e) {
                if (awaiting_cpu)
                    return;

                let xdiff = e.touches[0].pageX - initialX;
                let ydiff = e.touches[0].pageY - initialY;

                if (keypress_active){
                    // left or right move
                    if (Math.abs(xdiff) > touchThreshold){
                        if (xdiff < 0)
                            move_type = "left";
                        else
                            move_type = "right";
                        keypress_active = false;
                        update_needed = true;
                        move_made = true;
                    }
    
                    // up or down move
                    else if (Math.abs(ydiff) > touchThreshold){
                        if (ydiff < 0)
                            move_type = "up";
                        else
                            move_type = "down";
                        keypress_active = false;
                        update_needed = true;
                        move_made = true;
                    }
                }
            }

            function touchendHandler(e) {
                keypress_active = false;
            }

            // ------------------------------------------------------------------
            
            // ------------------------ Game Logic ------------------------

            function makeMove(direction){
                console.log("makeMove(" + direction + ")");
                my_board.move(direction);

                // check for endgame
                if (my_board.board_state != "continue" && my_board.board_state != "no_change"){
                    console.log("endgame reached");
                    endgame = true;
                }

                drawBoard();
            }

            function resetBoard(){
                console.log("resetBoard()");
                my_board = new Board(goal);
                drawBoard();
            }

            // ------------------------------------------------------------------

            // draw the grid
            function drawBoard(){
                /* update the game board */
                console.log("drawBoard()");

                if (!my_board){
                    console.log("ERROR: board not received in drawBoard");
                    return;
                }

                // clear old squares and settings
                while(tile_container.hasChildNodes()){
                    tile_container.removeChild(tile_container.firstChild);
                }
                if (turn_message.classList.contains("player1-text")){
                    turn_message.classList.remove("player1-text")
                }
                if (turn_message.classList.contains("player2-text")){
                    turn_message.classList.remove("player2-text")
                }

                if (endgame_msg.classList.contains("player1-text")){
                    endgame_msg.classList.remove("player1-text")
                }
                if (endgame_msg.classList.contains("player2-text")){
                    endgame_msg.classList.remove("player2-text")
                }


                // iterate through grid
                for (var row = 0; row < 4; ++row){
                    for (var col = 0; col < 4; ++col){
                        text = "0";
                        owner = null;
                        player = -1;

                        // parse the current number
                        text = my_board.board[col][row].toString();                            
                        
                        // set the owner
                        if (text != 0){
                            if (my_board.owner[col][row] == 0)
                                player = 1;
                            else 
                                player = 2;
                        }

                        // draw new square
                        if (text != 0){
                            const newSquare = document.createElement("div");
                            var loc = "tile-position-" + (row + 1) + "-" + (col + 1);
                            newSquare.classList.add(loc);
                            tile_container.appendChild(newSquare);
                            newSquare.classList.add("tile");

                            // set color
                            if (player == 1)
                                newSquare.classList.add("player1");
                            else
                                newSquare.classList.add("player2");

                            // set the text
                            newSquare.innerHTML = text;
                        }
                    }
                }

                // write the scores
                player1_score.innerHTML = p1possessive + " score -> <strong>" + my_board.p1score + "</strong>";
                player2_score.innerHTML = "<strong>" + my_board.p2score + "</strong> <- " + p2possessive + " score";
                // determine game state
                if (my_board.board_state == "tie"){
                    text = "It's a tie!";
                }

                else if (my_board.board_state == "win1"){
                    turn_message.classList.add("player1-text");
                    if (p1name == "You")
                        text = p1name + " win!";
                    else
                        text = p1name + " win!";
                }

                else if (my_board.board_state == "win2"){
                    turn_message.classList.add("player2-text");
                    if (p2name == "CPU")
                        text = p2name + " wins :(";
                    else
                    text = p2name + " wins!";
                }

                // normal
                else{
                    if (my_board.player == 0){
                        turn_message.classList.add("player1-text");
                        if (my_board.board_state == "no_change")
                            text = "No change, move again";
                        else
                            text = p1possessive + " turn";
                    }

                    else{
                        turn_message.classList.add("player2-text");
                        if (my_board.board_state == "no_change")
                            text = "No change, move again";
                        else
                            text = p2possessive + " turn";
                    }
                }
                turn_message.innerHTML = text;

                if (endgame){
                    endgame_msg.innerHTML = text;
                    if (my_board.board_state == "win1")
                        endgame_msg.classList.add("player1-text");
                    else if (my_board.board_state == "win2")
                        endgame_msg.classList.add("player2-text");
                    endgame_msg.style.zIndex = 10;
                    endgame_msg.style.display = "inherit";
                }
            }

            function mainLoop(){

                // process keypress
                if (update_needed){
                    if (resetPressed){
                        console.log("resetting");
                        resetBoard();
                        endgame = false;
                        resetPressed = false;
                        awaiting_cpu = false;
                        endgame_msg.style.display = "none";
                    }

                    // move made
                    else if (!endgame && move_made && !awaiting_cpu){
                        console.log("player is making move " + move_type);
                        makeMove(move_type);

                        // cpu move
                        if (singleplayer && my_board.board_state == "continue"){
                            // flag to prevent player from moving during delay
                            awaiting_cpu = true;

                            // search for the best possible moves, return in sorted order
                            var dirs = my_board.explore_moves();
                            if (!dirs){
                                dirs = [[0, "up"],[ 0, "down"],[ 0, "left"],[ 0, "right"]]
                            }
                            var options = [], costs = [];
                            for (let idx = 0; idx < dirs.length; ++idx){
                                options.push(dirs[idx][1]);
                                costs.push(dirs[idx][0]);
                            }
                            console.log("options: " + options + ", costs: " + costs);
                            
                            if (difficulty == "easy")
                                weight = [4, 3, 2, 1];
                            else if (difficulty == "medium")
                                weight = [5, 3, 1, 1];
                            else if (difficulty == "hard")
                                weight = [80, 10, 5, 5];
                            else if (difficulty == "impossible")
                                weight = [97, 1, 1, 1];
                            else
                                weight = [1, 1, 1, 1];

                            // cpu delay and move
                            function cpumove(){
                                move = selectrand(options, weight);
                                console.log("CPU moving in direction " + move + " with difficulty " + difficulty);
                                makeMove(move);
                                
                                // failsafe: try every direction if first fails
                                for (let idx = 0; idx < 4; ++idx){
                                    if (my_board.board_state != "no_change")
                                        break;
                                    move = options[idx];
                                    console.log("FAILSAFE: CPU moving in direction " + move + " with difficulty " + difficulty);
                                    makeMove(move);
                                }
                                } while (my_board.board_state == "no_change");
                            }
                            sleep(1500)
                                .then(() => cpumove())
                                .then(() => awaiting_cpu = false);
                    }
                    update_needed = false;
                }
            }
            
            resetBoard();
            setInterval(mainLoop, 10);
        </script>
    </body>
</html>
