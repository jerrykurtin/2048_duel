<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="styles.css">
        <title>2048 Duel</title>
    </head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1J9CBQR5PG"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-1J9CBQR5PG');
    </script>
    <body>
        <div class="container">
            <div class="title-container">
                <h1 class="title">2048 Duel!</h1>
                <div class="board_info-container">
                    <div class="board_info-left player1 text text-left">
                        <div class="board_info-internal text header" id="player1-header">Player 1</div>
                        <div class="board_info-internal text" id="player1-timer">Time - </div>
                        <div class="board_info-internal text" id="player1-score"></div>
                    </div>
                    <div class="board_info-center">
                        <button class="board_info-reset bolded" id="reset-button">Reset (r)</button>
                        <p id="settings-link"><a href="#settings-header">How to play</a></p>

                    </div>
                    <div class="board_info-right player2 text text-right">
                        <div class="board_info-internal text header" id="player2-header">Player 2</div>
                        <div class="board_info-internal text" id="player2-timer">  -Time</div>
                        <div class="board_info-internal text" id="player2-score"></div>
                    </div>
                </div>
    
            </div>
            <div class="game-container" id="game-container">
                <div class="endgame-msg text" id="endgame-msg"></div>
                <div class="endgame-msg text" id="start-msg">
                    <button id="start-button">Start Timed Game</button>
                </div>
                <div class="grid-container">
                    <div class="grid-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                    <div class="grid-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                    <div class="grid-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                    <div class="grid-row final-row">
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell"></div>
                        <div class="grid-cell final-cell"></div>
                    </div>
                </div>
                <div class="tile-container" id="tile-container"></div>
            </div>
            <div>
                <div class="turn-container">
                    <div class="turn text" id="turn"></div>
                </div>
                <h2 id="settings-header">Settings</h2>
                <div class="settings-container">
                    <div class="settings-inner">
                        <div class="dropdown">
                            <button class="dropbtn" id="gamemode-dropdown">Gamemode: Solo</button>
                            <div class="dropdown-content">
                              <button class="dropdown-element" id="gamemode-singleplayer">Solo</button>
                              <button class="dropdown-element" id="gamemode-multiplayer">Local Multiplayer</button>
                            </div>
                        </div>
                        <div class="dropdown">
                            <button class="dropbtn" id="difficulty-dropdown">Difficulty: Easy</button>
                            <div class="dropdown-content">
                              <button class="dropdown-element" id="difficulty-easy">Easy</button>
                              <button class="dropdown-element" id="difficulty-medium">Medium</button>
                              <button class="dropdown-element" id="difficulty-hard">Hard</button>
                              <button class="dropdown-element" id="difficulty-impossible">Impossible</button>
                            </div>
                        </div>
                        <div class="dropdown">
                            <button class="dropbtn" id="timer-dropdown">Timer: None</button>
                            <div class="dropdown-content">
                              <button class="dropdown-element" id="timer-none">None</button>
                              <button class="dropdown-element" id="timer-chess">Chess</button>
                              <!-- <button class="dropdown-element" id="timer-speed">Speed</button> -->
                            </div>
                        </div>
                    </div>
                    <div class="settings-inner">
                        <div class="dropdown">
                            <button class="dropbtn" id="goal-dropdown">Goal: 64</button>
                            <div class="dropdown-content">
                              <button class="dropdown-element" id="goal-32">32</button>
                              <button class="dropdown-element" id="goal-64">64</button>
                              <button class="dropdown-element" id="goal-128">128</button>
                            </div>
                        </div>
                        <div class="dropdown">
                            <button class="dropbtn text player1" id="p1color-dropdown">Player 1: unknown</button>
                            <div class="dropdown-content">
                              <button class="dropdown-element" id="p1color-green">Green</button>
                              <button class="dropdown-element" id="p1color-blue">Blue</button>
                              <button class="dropdown-element" id="p1color-salmon">Salmon</button>
                              <button class="dropdown-element" id="p1color-purple">Purple</button>
                            </div>
                        </div>
                        <div class="dropdown">
                            <button class="dropbtn text player2" id="p2color-dropdown">Player 2: unknown</button>
                            <div class="dropdown-content">
                              <button class="dropdown-element" id="p2color-green">Green</button>
                              <button class="dropdown-element" id="p2color-blue">Blue</button>
                              <button class="dropdown-element" id="p2color-salmon">Salmon</button>
                              <button class="dropdown-element" id="p2color-purple">Purple</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <h2>How to play</h2>
            <p>Use the arrow keys (swipe for mobile) to move the pieces. When pieces with the same number move into each other, the
                pieces merge and double.  </p>
            <p><strong>Duel:</strong> The two players take turns. On your turn, merge one of your pieces with one of your opponents to steal the piece. Merging two of your own pieces or two of your opponent's doesn't change the ownership. 
                The winner is the first to create the goal piece (64) or the one with the highest score when there are no available moves.
            </p>
            <p><strong>Gamemodes:</strong>
                <ul>
                    <li><strong>Solo: </strong>Play against the computer. Try out the impossible difficulty for a challenge!</a></li>
                    <li><strong>Local Multiplayer: </strong>Play against your friends on the same device!</li>
                    <li><strong>Chess Mode: </strong>Adds a clock that runs down during your turn and doesn't reset. If it reaches 0, your opponent wins! This is only available in multiplayer.</li>
                </ul>
            </p>
            <p><strong>Credits:</strong> This game is my fresh take on <a href="https://play2048.co">2048</a>. Have fun :) ~Jerry</p>
        </div>
        
        <script>
            // ----------------------- Settings and Setup -----------------------
            var tile_container = document.getElementById("tile-container");
            var game_container = document.getElementById("game-container");
            var player1_score = document.getElementById("player1-score");
            var player2_score = document.getElementById("player2-score");
            var turn_message = document.getElementById("turn");
            var reset_button = document.getElementById("reset-button");
            var endgame_msg = document.getElementById("endgame-msg");
            var start_msg = document.getElementById("start-msg");

            var rightPressed = false;
            var leftPressed = false;
            var upPressed = false;
            var downPressed = false;
            var resetPressed = false;
            var keypress_active = false;
            var update_needed = false;
            var move_made = false;

            // board information
            var goal = 64;
            var my_board = null;
            var move_type = null;
            var endgame = false;
            var colorblind = false;
            var p1color_id = "player1";
            var p2color_id = "player2";
            var draw_time = Date.now();

            // singleplayer
            var awaiting_cpu = false;
            var singleplayer = true;
            var difficulty = "easy";    // "easy", "medium", "hard", "impossible"
            var p1name = "You";
            var p1possessive = "Your";
            var p2name = "CPU";
            var p2possessive = "CPU's";

            // timed
            var time_type = null;    // null, "chess", "speed"
            var time_start = null;
            var time_paused = false;
            var chess_limit = 90 * 1000;
            var time_p1 = chess_limit;
            var time_p2 = chess_limit;

            // holds the http request object
            var xhr = null;

            // holds details on touch controls
            var initialX = null;
            var initialY = null;
            var touchThreshold = 30;



            // ------------------------------------------------------------------

            // --------------------------- Game Logic ---------------------------
            var cardinal_moves = ["up", "down", "left", "right"];

            class Board {
                constructor(win_condition=64, copy_board=null) {
                    /**
                     * @param {int} win_condition - The number to win at. Default: 64 (ignored if copy_board is defined)
                     * @param {Board} copy_board - The board to copy, default: null
                     */

                    // board variables
                    this.board_size = 4;
                    this.win_condition = win_condition;
                    this.squares_added = 1;

                     // my workaround for a copy constructor
                     if (copy_board){
                        this.board = deepCopy(copy_board.board);
                        this.owner = deepCopy(copy_board.owner);
                        this.p1score = copy_board.p1score;
                        this.p2score = copy_board.p2score;
                        this.win_condition = copy_board.win_condition;

                        this.board_state = copy_board.board_state;
                        this.player = copy_board.player;
                        this.first_round = copy_board.first_round;

                        return;
                     }


                    this.board_state = "continue";  // "continue", "no_change", "win1", "win2", "tie"
                    this.player = 0;
                    this.first_round = true;

                    // create board
                    this.board = new Array(this.board_size);
                    for (let r = 0; r < this.board.length; ++r){
                        this.board[r] = new Array(this.board_size).fill(0);
                    }
                    this.owner = new Array(this.board_size);
                    for (let r = 0; r < this.owner.length; ++r){
                        this.owner[r] = new Array(this.board_size).fill(-1);
                    }

                    // initialize the first numbers
                    var st1 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]
                    var st2 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]
                    while (st1[0] == st2[0] || st1[1] == st2[1])
                        st2 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]

                    this.board[st1[0]][st1[1]] = 2
                    this.owner[st1[0]][st1[1]] = 0

                    this.board[st2[0]][st2[1]] = 2
                    this.owner[st2[0]][st2[1]] = 1


                    this.p1score = 2;
                    this.p2score = 2;
                }

                move(dir, add_squares=true){
                    /* Moves in the direction specified, returning the array of actions for each block */
                    
                    // endgame: grid is full
                    if (!this.move_exists()){
                        if (this.p1score > this.p2score)
                            this.board_state = "win1";
                        else if (this.p1score < this.p2score)
                            this.board_state = "win2";
                        else
                            this.board_state = "tie";
                        return null;
                    }

                    if (this.board_state != "continue" && this.board_state != "no_change"){
                        console.log("ERROR: cannot move in endgame!");
                        return null;
                    }
                    var prev_state = deepCopy(this.board);

                    // make the move
                    var actions = null;
                    if (dir == "up")
                        actions = this.up();
                    else if (dir == "down")
                        actions = this.down();
                    else if (dir == "left")
                        actions = this.left();
                    else if (dir == "right")
                        actions = this.right();
                    else{
                        console.log("ERROR: invalid direction (" + dir + ")");
                        return null;
                    }

                    // check for no change
                    if (deepCompare(this.board, prev_state)){
                        this.board_state = "no_change";
                        return null;
                    }
                    else{
                        this.board_state = "continue";
                    }

                    // check for win condition and add squares
                    var cands = new Array();
                    this.p1score = 0;
                    this.p2score = 0;
                    for (let row = 0; row < this.board.length; ++row){
                        for (let col = 0; col < this.board[0].length; ++col){

                            // win!
                            if (this.board[row][col] == this.win_condition){
                                if (this.owner[row][col] == 0){
                                    this.board_state = "win1";
                                }
                                else{
                                    this.board_state = "win2";
                                }
                            }

                            // empty square
                            else if (this.board[row][col] == 0){
                                cands.push([row, col]);
                            }

                            // number square, add to score
                            else {
                                if (this.owner[row][col] == 0)
                                    this.p1score += this.board[row][col];
                                else
                                    this.p2score += this.board[row][col];
                            }
                        }
                    }

                    // elimination win
                    if (this.p1score == 0 || this.board_state == "win2"){
                        this.board_state = "win2";
                        return actions;
                    }
                    else if (this.p2score == 0 || this.board_state == "win1"){
                        this.board_state = "win1";
                        return actions;
                    }

                    // endgame: grid can't add any values
                    if (cands.length < this.squares_added){
                        if (this.p1score > this.p2score)
                            this.board_state = "win1";
                        else if (this.p1score < this.p2score)
                            this.board_state = "win2";
                        else
                            this.board_state = "tie";
                        return actions;
                    }

                    // add squares
                    if (add_squares){
                        // select new value(s) to add
                        var new_squares = new Array();
                        if (this.first_round && this.squares_added == 1){
                            new_squares.push(4);
                            this.first_round = false;
                        }
                        else{
                            var choices = new Array();
                            for (let twos = 0; twos < 3; ++twos)
                            choices.push(2);
                            for (let fours = 0; fours < 1; ++fours)
                            choices.push(4);
                            
                            for (let ch = 0; ch < this.squares_added; ++ch)
                            new_squares.push(choices[randint(0, choices.length - 1)]);
                        }
                        
                        // add the new value(s) to random location(s)
                        var locations = new Array();
                        for (let ch = 0; ch < this.squares_added; ++ch)
                        locations.push(cands[randint(0, cands.length - 1)]);
                        
                        for (let square = 0; square < new_squares.length; ++square){
                            this.board[locations[square][0]][locations[square][1]] = new_squares[square];
                            this.owner[locations[square][0]][locations[square][1]] = this.player;
                            if (actions) actions[2][locations[square][0]][locations[square][1]] = true;

                            if (this.player == 0)
                                this.p1score += new_squares[square];
                            else
                                this.p2score += new_squares[square];
                        }
                    }

                    // endgame: after adding squares, no move exists
                    if (!this.move_exists()){
                        if (this.p1score > this.p2score)
                            this.board_state = "win1";
                        else if (this.p1score < this.p2score)
                            this.board_state = "win2";
                        else
                            this.board_state = "tie";
                        return actions;
                    }
                        
                    // switch to the next player
                    this.player = (this.player + 1) % 2;

                    return actions;
                }

                move_exists(){
                    /* Test if available move exists */
                    var temp_board = new Board(-1, this);
                    var prev_state = temp_board.board;
                    
                    temp_board.up();
                    if (!deepCompare(prev_state, temp_board.board))
                        return true;
                    temp_board.down();
                    if (!deepCompare(prev_state, temp_board.board))
                        return true;
                    temp_board.left();
                    if (!deepCompare(prev_state, temp_board.board))
                        return true;
                    temp_board.right();
                    if (!deepCompare(prev_state, temp_board.board))
                        return true;

                    return false;
                }
                
                left(){
                    /* make a left movement */

                    // store the movement information
                    var actions = [];
                    var deleted = [];
                    var created = [];

                    for (let row = 0; row < this.board.length; ++row){
                        // store the new row
                        var newrow = Array(this.board.length).fill(0);
                        var newowner = Array(this.board.length).fill(-1);
                        // stores [action, [end_row, end_col]] -> null, "move", "delete", "create"
                        var actionrow = Array(this.board.length).fill([null, null, null]);
                        var deleterow = Array(this.board.length).fill(false);
                        var createrow = Array(this.board.length).fill(false);
                        // stores start_col for each position with a piece
                        var actionrow_source = Array(this.board.length).fill(null);
                        var newidx = 0;

                        for (let col = 0; col < this.board[0].length; ++col){
                            if (this.board[row][col] != 0){

                                // merge
                                if (newidx > 0 && this.board[row][col] == newrow[newidx - 1]){
                                    newrow[newidx - 1] = newrow[newidx - 1] * -2; // negative prevents double merging

                                    // determine ownership of square
                                    if (newowner[newidx - 1] != this.owner[row][col]){
                                        newowner[newidx - 1] = this.player;
                                    }

                                    // update destination for delete and move
                                    actionrow[col] = ["move", row, newidx - 1];

                                    // update actions for 2 deleted and 1 created square
                                    // deleterow[actionrow_source[newidx - 1]] = true;
                                    deleterow[newidx - 1] = true;
                                    createrow[newidx - 1] = true;
                                }

                                // move without merging
                                else{
                                    newrow[newidx] = this.board[row][col];
                                    newowner[newidx] = this.owner[row][col];
                                    newidx += 1;

                                    // update actionrow
                                    actionrow[col] = ["move", row, newidx - 1];
                                    actionrow_source[newidx - 1] = col;
                                }
                            }
                        }

                        // update the board
                        for (let col = 0; col < this.board[0].length; ++col)
                            newrow[col] = Math.abs(newrow[col]);
                        this.board[row] = newrow;

                        actions.push(actionrow);
                        deleted.push(deleterow);
                        created.push(createrow);

                        // update the owner
                        this.owner[row] = newowner;

                    }
                    return [actions, deleted, created];
                }

                up(){
                    /* make an up movement */
                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    var actions = this.left();

                    
                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);
                    actions = rotateActionsClock(actions);

                    return actions;
                }

                right(){
                    /* make a right movement */
                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    var actions = this.left();

                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);

                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);

                    actions = rotateActionsClock(actions);
                    actions = rotateActionsClock(actions);
                    return actions;
                }

                down(){
                    /* make a downward movement */
                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);

                    var actions = this.left();

                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);
                    actions = rotateActionsCounter(actions);
                    return actions;
                }

                find_move_value(){
                    /* finds the maximum and minimum next-turn move values for a board (p1score - p2score) */
                    // TO-DO: add depth argument for recursion

                    var scores = [];
                    for (let dir = 0; dir < 4; ++dir){
                        var temp_board = new Board(-1, this);
                        temp_board.move(cardinal_moves[dir], false);
                        if (temp_board.board_state == "no_change")
                            continue;

                        // promote wins/ don't promote losses
                        else if (temp_board.board_state == "win1"){
                            if (temp_board.player == 1)
                                scores.push(-10000)
                            else
                                scores.push(10000)
                        }
                        else if (temp_board.board_state == "win2"){
                            if (temp_board.player == 0)
                                scores.push(-10000)
                            else
                                scores.push(10000)
                        }

                        else 
                            scores.push(temp_board.p1score - temp_board.p2score);
                    }

                    if (!scores){
                        return null;
                    }
                    // console.log("all possible move differentials for player2: " + scores);

                    return [Math.min(...scores), Math.max(...scores)];
                }

                explore_moves() {

                    /* const function to explore the best moves. Returns the moves in order of their average 2-turn payout */
                    var dirs = [[0, cardinal_moves[0]], [0, cardinal_moves[1]], [0, cardinal_moves[2]], [0, cardinal_moves[3]]];
                    var player = this.player;
                    // var initial_diff = this.p1score - this.p2score;
                    console.log("received board:\n" + this.build_grid() + " as player " + (player + 1));
                    // console.log("initial differential (p1score - p2score): " + initial_diff);

                    // search the moves in every direction
                    for (let dir = 0; dir < 4; ++dir){
                        var temp_board = new Board(-1, this);
                        temp_board.move(cardinal_moves[dir], false);
                        // var move_diff = temp_board.p1score - temp_board.p2score - initial_diff;
                        // move_diff = 0;

                        console.log("exploring move " + cardinal_moves[dir] + ", has board\n" + temp_board.build_grid());

                        // don't promote no_change
                        if (temp_board.board_state == "no_change"){
                            dirs[dir][0] = -Number.MAX_VALUE;
                        }

                        // promote win, don't promote loss
                        else if (temp_board.board_state == "win1"){
                            if (player == 0)
                                dirs[dir][0] = Number.MAX_VALUE;
                            else
                                dirs[dir][0] = -Number.MAX_VALUE;
                        }
                        else if (temp_board.board_state == "win2"){
                            if (player == 1)
                                dirs[dir][0] = Number.MAX_VALUE;
                            else
                                dirs[dir][0] = -Number.MAX_VALUE;
                        }

                        // calculate the best next move based on minimum oponnent's score
                        else{
                            let min_max = temp_board.find_move_value();
                            if (player == 0)
                                var added = min_max[0];
                            else
                                var added = min_max[1];
                            // console.log("choosing opponent move with differential " + added);
                            dirs[dir][0] =  added;  // + move_diff;
                            console.log("if the opponent plays optimally, the max score differential they can reach is " + dirs[dir][0]);
                            if (player == 1){
                                dirs[dir][0] = -1 * dirs[dir][0];
                            }
                        }

                        if (dirs[dir][0] == Number.MAX_VALUE){
                            console.log("prioritizing this move!");
                        }
                        else if (dirs[dir][0] == -Number.MAX_VALUE){
                            console.log("avoiding this move at all costs!");
                        }
                    }

                    // sorts in reverse order
                    dirs.sort(function(a,b){return b[0] - a[0]})
                    // remove all -infinity values
                    while (dirs[dirs.length - 1][0] == -Number.MAX_VALUE)
                        dirs.pop();
                    return dirs;
                }

                build_grid(){
                    var board = deepCopy(this.board);
                    for (let r = 0; r < board.length; ++r){
                        for (let c = 0; c < board[0].length; ++c){
                            if (this.owner[r][c] == 1)
                                board[r][c] *= -1;
                        }
                    }

                    var ans = "";
                    for (let row = 0; row < board.length; ++row){
                        for (let col = 0; col < board[0].length; ++col){
                            ans += board[row][col] + "\t";
                        }
                        ans += "\n";
                    }

                    return ans;
                }
            }

            // helper functions ---------------------------
            function randint(min, max){
                /* random number between min and max, inclusive */
                return Math.floor(Math.random() * (max - min + 1) ) + min;
            }

            function randchoice(arr){
                let idx = randint(0, arr.length - 1);
                return arr[idx];
            }

            const deepCopy = (items) => items.map(item => Array.isArray(item) ? deepCopy(item) : item);


            function deepCopy3d(arr){
                var copy = [];
                for (let row = 0; row < arr.length; ++row){
                    var temprow = [];
                    for (let col = 0; col < arr[0].length; ++col){
                        var tempcol = [];
                        for (let thrd = 0; thrd < arr[0][0].length; ++thrd){
                            tempcol.push(arr[row][col][thrd]);
                        }
                        temprow.push(tempcol);
                    }
                    copy.push(temprow);
                }
                return copy;
            }

            function deepCompare(arr1, arr2){
                /* determines equality between two arrays */
                if (arr1.length != arr2.length || arr1[0].length != arr2[0].length)
                    return false;

                for (let r = 0; r < arr1.length; ++r){
                    for (let c = 0; c < arr1[0].length; ++c){
                        if (arr1[r][c] != arr2[r][c])
                            return false;
                    }
                }

                return true;
            }

            function rotateCounter(arr){
                /* rotate a square array 90 degrees counterclockwise */
                newarr = deepCopy(arr);

                for (let row = 0; row < arr.length; ++row){
                    for (let col = 0; col < arr[0].length; ++col){
                        newarr[newarr.length - col - 1][row] = arr[row][col];
                    }
                }

                return newarr;
            }

            function rotateCoordsCounter(coords, length=4){
                return [length - coords[1] - 1, coords[0]];
            }

            function rotateActionsCounter(actions){
                // actions = [actions, deleted, created]

                // rotate the coordinates in actions[0]
                for (let row = 0; row < actions[0].length; ++row){
                    for (let col = 0; col < actions[0][0].length; ++col){
                        let coords = [actions[0][row][col][1], actions[0][row][col][2]]
                        coords = rotateCoordsCounter(coords);
                        actions[0][row][col][1] = coords[0];
                        actions[0][row][col][2] = coords[1];
                    }
                }

                for (let action = 0; action < actions.length; ++action){
                    actions[action] = rotateCounter(actions[action]);
                }
                
                return actions;
            }

            function rotateClock(arr){
                /* rotate a square array 90 degrees clockwise */
                newarr = deepCopy(arr);

                for (let row = 0; row < arr.length; ++row){
                    for (let col = 0; col < arr[0].length; ++col){
                        newarr[col][arr.length - row - 1] = arr[row][col];
                    }
                }

                return newarr
            }

            function rotateCoordsClock(coords, length=4){
                return [coords[1], length - [coords[0]] - 1];
            }

            function rotateActionsClock(actions){
                // actions = [actions, deleted, created]

                // rotate the coordinates in actions[0]
                for (let row = 0; row < actions[0].length; ++row){
                    for (let col = 0; col < actions[0][0].length; ++col){
                        let coords = [actions[0][row][col][1], actions[0][row][col][2]]
                        coords = rotateCoordsClock(coords);
                        actions[0][row][col][1] = coords[0];
                        actions[0][row][col][2] = coords[1];
                    }
                }

                for (let action = 0; action < actions.length; ++action){
                    actions[action] = rotateClock(actions[action]);
                }
                
                return actions;
            }

            function selectrand(options, weight) {
                /* select from array with given weights */
                var choices = new Array();
                for (let idx = 0; idx < options.length; ++idx){
                    for (let count = 0; count < weight[idx]; ++count){
                        choices.push(options[idx]);
                    }
                }

                return randchoice(choices);
            }

            function print_grid(grid){
                ans = "";
                for (let row = 0; row < grid.length; ++row){
                    for (let col = 0; col < grid[0].length; ++col){
                        ans += grid[row][col] + "\t";
                    }
                    ans += "\n";
                }
                return ans;
            }

            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // ------------------------------------------------------------------

            // --------------------- Listeners and Handlers ---------------------
            document.addEventListener("keydown", keyDownHandler, false);
            document.addEventListener("keyup", keyUpHandler, false);
            document.addEventListener("touchstart", touchstartHandler, false);
            document.addEventListener("touchmove", touchmoveHandler, false);
            document.addEventListener("touchend", touchendHandler, false);

            // start game button
            document.getElementById("start-button").addEventListener("click", function (){
                start_msg.classList.add("hidden");
                time_start = Date.now();
            }, false);

            function setColor(color, player){
                // no change: equal to either player 1 or player 2 color
                if (color == p1color_id || color == p2color_id){
                    console.log("setColor() can't change color to one already in use");
                    document.getElementById("p1color-dropdown").innerHTML = p1name + ": " + p1color_id;
                    document.getElementById("p2color-dropdown").innerHTML = p2name + ": " + p2color_id;
                    return;
                }

                // update stettings
                if (player == 1){
                    var prev_color = p1color_id;
                    p1color_id = color;
                    document.getElementById("p1color-dropdown").innerHTML = p1name + ": " + color;
                }
                else{
                    var prev_color = p2color_id;
                    p2color_id = color;
                    document.getElementById("p2color-dropdown").innerHTML = p2name + ": " + color;
                }

                console.log("setting player " + player + " color to " + color);

                // switch all existing colors
                let allcolor = document.getElementsByClassName(prev_color);
                while(allcolor.length > 0) {
                    allcolor[0].classList.add(color)
                    allcolor[0].classList.remove(prev_color);
                }
            }

            // color settings: p1
            document.getElementById("p1color-green").addEventListener("click", function (){
                setColor("green", 1);
            }, false)
            document.getElementById("p1color-blue").addEventListener("click", function (){
                setColor("blue", 1);
            }, false);
            document.getElementById("p1color-salmon").addEventListener("click", function (){
                setColor("salmon", 1);
            }, false);
            document.getElementById("p1color-purple").addEventListener("click", function (){
                setColor("purple", 1);
            }, false);

            // color settins: p2
            document.getElementById("p2color-green").addEventListener("click", function (){
                setColor("green", 2);
            }, false)
            document.getElementById("p2color-blue").addEventListener("click", function (){
                setColor("blue", 2);
            }, false);
            document.getElementById("p2color-salmon").addEventListener("click", function (){
                setColor("salmon", 2);
            }, false);
            document.getElementById("p2color-purple").addEventListener("click", function (){
                setColor("purple", 2);
            }, false);

            // colorblind button (for matt bullock)
            // document.getElementById("colorblind-button").addEventListener("click", function (){
            //     console.log("switching all elements between contrasts");
            //     if (colorblind){
            //         colorblind = false;
                    
            //         // switch all existing colors to normal
            //         let allp1 = document.getElementsByClassName("player1-contrast");
            //         while(allp1.length > 0) {
            //             allp1[0].classList.add("player1");
            //             allp1[0].classList.remove("player1-contrast")
            //         }
            //         let allp2 = document.getElementsByClassName("player2-contrast");
            //         while(allp2.length > 0) {
            //             allp2[0].classList.add("player2");
            //             allp2[0].classList.remove("player2-contrast")
            //         }

            //         // p1color_id = "player1";
            //         // p2color_id = "player2";
            //         document.getElementById("colorblind-button").innerHTML = "High Contrast: Off";
            //     }

            //     else {
            //         colorblind = true;
            //         // switch all existing colors to high-contrast
            //         let allp1 = document.getElementsByClassName("player1");
            //         while(allp1.length > 0){
            //             allp1[0].classList.add("player1-contrast");
            //             allp1[0].classList.remove("player1")
            //         }
            //         let allp2 = document.getElementsByClassName("player2");
            //         while(allp2.length > 0){
            //             allp2[0].classList.add("player2-contrast");
            //             allp2[0].classList.remove("player2")
            //         }

            //         // p1color_id = "player1-contrast";
            //         // p2color_id = "player2-contrast";
            //         document.getElementById("colorblind-button").innerHTML = "High Contrast: On";
            //     }

            //     console.log("finished switching all elements");
            //     reset_colors = true;
            // }, false);

            // reset button
            reset_button.addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
            }, false);

            // originally, set gamemode to singleplayer
            document.getElementById("difficulty-dropdown").style.display = "inherit";
            document.getElementById("difficulty-dropdown").style.visibility = "visible";
            document.getElementById("timer-dropdown").style.display = "none";
            document.getElementById("timer-dropdown").style.visibility = "hidden";

            // set gamemode
            document.getElementById("gamemode-singleplayer").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                singleplayer = true;
                p1name = "You";
                p1possessive = "Your";
                p2name = "CPU";
                p2possessive = "CPU's";
                document.getElementById("gamemode-dropdown").innerHTML = "Gamemode: Solo";

                // turn on / off settings that do / don't apply
                document.getElementById("difficulty-dropdown").style.display = "inherit";
                document.getElementById("difficulty-dropdown").style.visibility = "visible";
                document.getElementById("timer-dropdown").style.display = "none";
                document.getElementById("timer-dropdown").style.visibility = "hidden";
            }, false);
            document.getElementById("gamemode-multiplayer").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                singleplayer = false;
                p1name = "Player 1";
                p1possessive = "Player 1's";
                p2name = "Player 2";
                p2possessive = "Player 2's";
                document.getElementById("gamemode-dropdown").innerHTML = "Gamemode: Local Multiplayer";

                // turn on / off settings that do / don't apply
                document.getElementById("difficulty-dropdown").style.display = "none";
                document.getElementById("difficulty-dropdown").style.visibility = "hidden";
                document.getElementById("timer-dropdown").style.display = "inherit";
                document.getElementById("timer-dropdown").style.visibility = "visible";
            }, false);

            // set the target
            document.getElementById("goal-32").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                goal = 32;
                document.getElementById("goal-dropdown").innerHTML = "Goal: 32";
            }, false);
            document.getElementById("goal-64").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                goal = 64;
                document.getElementById("goal-dropdown").innerHTML = "Goal: 64";
            }, false);
            document.getElementById("goal-128").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                goal = 128;
                document.getElementById("goal-dropdown").innerHTML = "Goal: 128";
            }, false);


            // set the difficulty
            document.getElementById("difficulty-easy").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                difficulty = "easy";
                document.getElementById("difficulty-dropdown").innerHTML = "Difficulty: Easy";
            }, false);
            document.getElementById("difficulty-medium").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                difficulty = "medium";
                document.getElementById("difficulty-dropdown").innerHTML = "Difficulty: Medium";
            }, false);
            document.getElementById("difficulty-hard").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                difficulty = "hard";
                document.getElementById("difficulty-dropdown").innerHTML = "Difficulty: Hard";
            }, false);
            document.getElementById("difficulty-impossible").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                difficulty = "impossible";
                document.getElementById("difficulty-dropdown").innerHTML = "Difficulty: Impossible";
            }, false);

            // set the timer
            document.getElementById("timer-none").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                time_type = null;
                document.getElementById("timer-dropdown").innerHTML = "Timer: None";
            }, false);
            document.getElementById("timer-chess").addEventListener("click", function (){
                resetPressed = true;
                update_needed = true;
                time_type = "chess";
                document.getElementById("timer-dropdown").innerHTML = "Timer: Chess";
            }, false);
            // document.getElementById("timer-speed").addEventListener("click", function (){
            //     resetPressed = true;
            //     update_needed = true;
            //     time_type = "speed";
            //     document.getElementById("timer-dropdown").innerHTML = "Timer: Speed";
            // }, false);


            function keyDownHandler(e) {

                // prevent arrow keys from scrolling
                if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                    e.preventDefault();
                }   

                if (!awaiting_cpu && Date.now()){
                    if(e.key == "Right" || e.key == "ArrowRight" || e.key == "d" || e.key == "KeyD") {
                        rightPressed = true;
                        move_type = "right";
                    }
                    else if(e.key == "Left" || e.key == "ArrowLeft" || e.key == "a" || e.key == "KeyA") {
                        leftPressed = true;
                        move_type = "left";
                    }
                    else if (e.key == "Up" || e.key == "ArrowUp" || e.key == "w" || e.key == "KeyW"){
                        upPressed = true;
                        move_type = "up";
                    }
                    else if (e.key == "Down" || e.key == "ArrowDown" || e.key == "s" || e.key == "KeyS"){
                        downPressed = true;
                        move_type = "down";
                    }
                }

                if (e.key == "r" || e.key == "KeyR"){
                    resetPressed = true;
                }

                // set keypress active variable
                if (rightPressed || leftPressed || upPressed || downPressed || resetPressed){
                    if (!keypress_active){
                        keypress_active = true;
                        update_needed = true;
                        move_made = true;
                    }
                }
            }

            function keyUpHandler(e) {
                if(e.key == "Right" || e.key == "ArrowRight" || e.key == "d" || e.key == "KeyD") {
                    rightPressed = false;
                }
                else if(e.key == "Left" || e.key == "ArrowLeft" || e.key == "a" || e.key == "KeyA") {
                    leftPressed = false;
                }
                else if (e.key == "Up" || e.key == "ArrowUp" || e.key == "w" || e.key == "KeyW"){
                    upPressed = false;
                }
                else if (e.key == "Down" || e.key == "ArrowDown" || e.key == "s" || e.key == "KeyS"){
                    downPressed = false;
                }
                else if (e.key == "r" || e.key == "KeyR"){
                    resetPressed = false;
                }

                if (!rightPressed && !leftPressed && !upPressed && !downPressed && !resetPressed){
                    if (keypress_active){
                        keypress_active = false;
                    }
                }
            }
        
            
            // mobile device handlers
            function touchstartHandler(e) {
                initialX = e.touches[0].pageX;
                initialY = e.touches[0].pageY;
                
                // only allow swipes that start inside the game board
                // temp fix: don't check against right border
                let position = game_container.getBoundingClientRect();
                if (initialX > position.left && initialY > position.top && initialY < position.bottom)
                    keypress_active = true;
            }

            function touchmoveHandler(e) {
                if (awaiting_cpu)
                    return;

                let xdiff = e.touches[0].pageX - initialX;
                let ydiff = e.touches[0].pageY - initialY;

                if (keypress_active){
                    // left or right move
                    if (Math.abs(xdiff) > touchThreshold){
                        if (xdiff < 0)
                            move_type = "left";
                        else
                            move_type = "right";
                        keypress_active = false;
                        update_needed = true;
                        move_made = true;
                    }
    
                    // up or down move
                    else if (Math.abs(ydiff) > touchThreshold){
                        if (ydiff < 0)
                            move_type = "up";
                        else
                            move_type = "down";
                        keypress_active = false;
                        update_needed = true;
                        move_made = true;
                    }
                }
            }

            function touchendHandler(e) {
                keypress_active = false;
            }

            // ------------------------------------------------------------------
            
            // ------------------------ Game Logic ------------------------

            function makeMove(direction){
                console.log("makeMove(" + direction + ")");
                console.log("before making move, board is\n" + print_grid(my_board.board));

                var actions = my_board.move(direction);

                // check for endgame
                if (my_board.board_state != "continue" && my_board.board_state != "no_change"){
                    console.log("endgame reached");
                    endgame = true;
                }

                drawBoard(actions);
            }

            function resetBoard(){
                console.log("resetBoard()");
                my_board = new Board(goal);

                endgame = false;
                resetPressed = false;
                awaiting_cpu = false;
                endgame_msg.classList.add("hidden");

                // remove any existing squares
                while(tile_container.hasChildNodes()){
                    tile_container.removeChild(tile_container.firstChild);
                }

                // disable time reading
                if (singleplayer || !time_type){
                    start_msg.classList.add("hidden");
                    document.getElementById("player1-timer").style.visibility = "hidden";
                    document.getElementById("player1-timer").style.display = "none";
                    document.getElementById("player2-timer").style.visibility = "hidden";
                    document.getElementById("player2-timer").style.display = "none";
                }

                // reset time reading
                else{
                    document.getElementById("player1-timer").style.visibility = "visible";
                    document.getElementById("player1-timer").style.display = "inherit";
                    document.getElementById("player2-timer").style.visibility = "visible";
                    document.getElementById("player2-timer").style.display = "inherit";

                    if (time_type == "chess"){
                        time_start = null;
                        time_p1 = chess_limit;
                        time_p2 = chess_limit;
                        document.getElementById("player1-timer").innerHTML = "Time - <strong>" + Math.round((time_p1) / 1000) + "</strong";
                        document.getElementById("player2-timer").innerHTML = "<strong> " + Math.round((time_p2) / 1000) + "</strong> - Time";
                        if (start_msg.classList.contains("hidden"))
                            start_msg.classList.remove("hidden");
                    }
                }

                // set headers
                document.getElementById("player1-header").innerHTML = p1name;
                document.getElementById("player2-header").innerHTML = p2name;

                // make sure that the colors are correct
                setColor(p1color_id, 1);
                setColor(p2color_id, 2);

                // DEBUG
                // my_board.board = [
                //     [2, 2, 0, 0],
                //     [2, 0, 0, 2],
                //     [2, 4, 2, 0],
                //     [0, 0, 2, 2]
                // ]

                // my_board.owner = [
                //     [1, 1, -1, -1],
                //     [1, -1, -1, 1],
                //     [1, 1, 1, -1],
                //     [-1, -1, 0, 0]
                // ]

                // console.log("before move, board is\n" + print_grid(my_board.board));
                // var actions = my_board.move("left");
                // console.log("after left move, board is\n" +  print_grid(my_board.board));
                // console.log("actions: ", actions);

                drawBoard();
            }

            // ------------------------------------------------------------------

            // draw the grid
            function drawBoard(actions=null){
                /* update the game board */

                draw_time = Date.now();

                if (my_board.board_state == "no_change"){
                    console.log("skipping drawBoard()");
                    return;
                }
                console.log("drawBoard()");
                console.log("board:\n" + print_grid(my_board.board));
                console.log("actions:", actions);

                if (!my_board){
                    console.log("ERROR: board not received in drawBoard");
                    return;
                }

                // clear old settings
                if (turn_message.classList.contains(p1color_id)){
                    turn_message.classList.remove(p1color_id)
                }
                if (turn_message.classList.contains(p2color_id)){
                    turn_message.classList.remove(p2color_id)
                }

                if (endgame_msg.classList.contains(p1color_id)){
                    endgame_msg.classList.remove(p1color_id)
                }
                if (endgame_msg.classList.contains(p2color_id)){
                    endgame_msg.classList.remove(p2color_id)
                }

                // moved squares

                for (var row = 0; row < 4; ++row){
                    for (var col = 0; col < 4; ++col){
                        if (actions && actions[0][row][col][0] == "move"){
                            var oldPos = "position-" + (row + 1) + "-" + (col + 1);
                            var newPos = "position-" + (actions[0][row][col][1] + 1) + "-" + (actions[0][row][col][2] + 1);

                            // select object with position that hasn't been moved yet
                            var movedSquare = document.querySelectorAll("." + oldPos + ":not(.moved)");

                            if (movedSquare.length > 1)
                                console.log("ERROR: selecting > 1 square in move from position " + oldPos + " to " + newPos);
                            if (movedSquare.length == 0)
                                console.log("ERROR: cannot find a square to move from " + oldPos + " to " + newPos);
                            else{
                                movedSquare = movedSquare[0];
                                console.log("moving square " + movedSquare.firstChild.innerHTML + " from " + oldPos + " to " + newPos);
                                movedSquare.classList.remove(oldPos);
                                if (movedSquare.classList.contains("tile-new"))
                                    movedSquare.classList.remove("tile-new");
                                movedSquare.classList.add(newPos);
                                // make sure we don't double move
                                movedSquare.classList.add("moved");
                            }
                        }
                    }
                }

                // remove moved tag
                const movedSquares = document.getElementsByClassName("moved");
                while (movedSquares.length > 0)
                    movedSquares[0].classList.remove("moved");

                // delete and build new squares
                for (var row = 0; row < 4; ++row){
                    for (var col = 0; col < 4; ++col){

                        text = "0";
                        owner = null;
                        player = -1;
                        // parse the current number
                        text = my_board.board[row][col].toString();                            
                        
                        // set the owner
                        if (text != 0){
                            if (my_board.owner[row][col] == 0)
                                player = 1;
                            else 
                                player = 2;
                        }

                        // delete squares
                        if (actions && actions[1][row][col] == true){
                            const elements = document.getElementsByClassName("position-"+ (row + 1) + "-" + (col + 1));
                            const rem_elements = document.getElementsByClassName("deleted");
                            console.log("trying to remove " + elements.length + " squares at " + (row + 1) + ", " + (col + 1));

                            var transitionEndHandler = function () {
                                while (rem_elements.length > 0){
                                    console.log("removing a square");
                                    // rem_elements[0].remove();
                                    rem_elements[0].parentNode.removeChild(rem_elements[0]);
                                }
                            }
                            // create a listener for each potential element, but skip all new elements
                            for (let elem = elements.length - 1; elem > -1; --elem){
                                elements[elem].classList.add("deleted");
                                elements[elem].addEventListener("transitionend", transitionEndHandler, true);
                                elements[elem].addEventListener("webkitTransitionEnd", transitionEndHandler, true);
                            }
                        }
                        
                        // brand-new square
                        if (!actions && text != 0 || actions && actions[2][row][col]){
                            console.log("new square at " + (row + 1) + ", " + (col + 1) + " is " + text);
                            const newSquareWrapper = document.createElement("div");
                            newSquareWrapper.classList.add("tile");
                            newSquareWrapper.classList.add("tile-new");
                            tile_container.appendChild(newSquareWrapper);
                            var loc = "position-" + (row + 1) + "-" + (col + 1);
                            newSquareWrapper.classList.add(loc);


                            const newSquare = document.createElement("div");
                            newSquare.classList.add("tile-inner");
                            newSquareWrapper.appendChild(newSquare);
                            // set color
                            if (player == 1)
                                newSquare.classList.add(p1color_id);
                            else
                                newSquare.classList.add(p2color_id);
                            newSquare.classList.add("background")

                            // set specific number settings
                            newSquare.classList.add("tile-" + text);

                            // set the text
                            newSquare.innerHTML = text;
                        }
                    }
                }

                // write the scores
                player1_score.innerHTML = "Score - <strong>" + my_board.p1score + "</strong>";
                player2_score.innerHTML = "<strong>" + my_board.p2score + "</strong> - Score";
                // determine game state
                if (my_board.board_state == "tie"){
                    text = "It's a tie!";
                }

                else if (my_board.board_state == "win1"){
                    turn_message.classList.add(p1color_id);
                    if (p1name == "You")
                        text = p1name + " win!";
                    else
                        text = p1name + " wins!";
                }

                else if (my_board.board_state == "win2"){
                    turn_message.classList.add(p2color_id);
                    if (p2name == "CPU")
                        text = p2name + " wins :(";
                    else
                    text = p2name + " wins!";
                }

                // normal
                else{
                    if (my_board.player == 0){
                        turn_message.classList.add(p1color_id);
                        if (my_board.board_state == "no_change")
                            text = "No change, move again";
                        else
                            text = p1possessive + " turn";
                    }

                    else{
                        turn_message.classList.add(p2color_id);
                        if (my_board.board_state == "no_change")
                            text = "No change, move again";
                        else
                            text = p2possessive + " turn";
                    }
                }
                turn_message.innerHTML = text;

                if (endgame){
                    endgame_msg.innerHTML = text;
                    if (my_board.board_state == "win1")
                        endgame_msg.classList.add(p1color_id);
                    else if (my_board.board_state == "win2")
                        endgame_msg.classList.add(p2color_id);
                    if (endgame_msg.classList.contains("hidden"))
                        endgame_msg.classList.remove("hidden");
                }
            }

            function verifyBoard(){
                /* ensures that the board is up-to-date */
                console.log("verifyBoard()");

                for (let row = 0; row < my_board.board.length; ++row){
                    for (let col = 0; col < my_board.board[0].length; ++col){

                        var position = "position-" + (row + 1) + "-" + (col + 1);
                        var text = my_board.board[row][col];
                        var player = my_board.owner[row][col] + 1;
                        var existing = document.querySelectorAll("." + position);

                        if (existing.length > 1){
                            console.log("multiple elements at position " + position);
                            // > 1 element
                            while (existing.length > 0){
                                // existing[0].remove();
                                existing[0].parentNode.removeChild(existing[0]);
                            }
                        }                        

                        if (existing.length == 0 && text != 0 || existing.length != 0 && text != existing[0].firstChild.innerHTML){
                            // add a new element

                            if (existing.length != 0){
                                console.log("out-of-place element at position " + position);
                                console.log("element is " + existing[0].firstChild.innerHTML + ", but should be " + text);
                                // existing[0].remove();
                                existing[0].parentNode.removeChild(existing[0]);
                            }
                            else{
                                console.log("missing element at position " + position);
                                console.log("element doesn't exist, but should be " + text);
                            }

                            if (text != 0){
                                const newSquareWrapper = document.createElement("div");
                                newSquareWrapper.classList.add("tile");
                                tile_container.appendChild(newSquareWrapper);
                                newSquareWrapper.classList.add(position);
    
                                const newSquare = document.createElement("div");
                                newSquare.classList.add("tile-inner");
                                newSquareWrapper.appendChild(newSquare);
                                // set color
                                if (player == 1)
                                    newSquare.classList.add(p1color_id);
                                else
                                    newSquare.classList.add(p2color_id);
                                newSquare.classList.add("background")
    
                                // set specific number settings
                                newSquare.classList.add("tile-" + text);
    
                                // set the text
                                newSquare.innerHTML = text;
                            }

                        }
                    }
                }
            }

            function mainLoop(){

                // ensure that the board is up-to-date
                if (draw_time && Date.now() - draw_time > 100){
                    verifyBoard();
                    draw_time = null;
                }

                // update time, check for out-of-time
                if (!endgame && time_type == "chess" && time_start){
                    if (my_board.player == 0){
                        let curr_time = (time_p1 - (Date.now() - time_start)) / 1000;
                        if (curr_time < 0){
                            my_board.board_state = "win2";
                            endgame = true;
                        }
                        document.getElementById("player1-timer").innerHTML = "Time - <strong>" + Math.round((time_p1 - (Date.now() - time_start)) / 1000) + "</strong>";
                    }
                    else {
                        let curr_time = (time_p1 - (Date.now() - time_start)) / 1000;
                        if (curr_time < 0){
                            my_board.board_state = "win1";
                            endgame = true;
                        }
                        document.getElementById("player2-timer").innerHTML = "<strong>" + Math.round((time_p2 - (Date.now() - time_start)) / 1000) + "</strong> - Time" ;
                    }

                    if (endgame){
                        drawBoard();
                    }
                }

                // process keypress
                if (update_needed){
                    if (resetPressed){
                        // console.log("resetting");
                        resetBoard();
                    }

                    // move made
                    else if (!endgame && move_made && !awaiting_cpu && (!time_type || time_start)){
                        console.log("player is making move " + move_type);
                        makeMove(move_type);

                        // switch time counter
                        if (!singleplayer && my_board.board_state == "continue"){
                            // note: switched bc player hasn't been updated yet
                            if (my_board.player == 1){
                                time_p1 -= (Date.now() - time_start);
                            }
                            else {
                                time_p2 -= (Date.now() - time_start);  
                            }
                            time_start = Date.now();
                        }

                        // cpu move
                        if (singleplayer && my_board.board_state == "continue"){
                            // flag to prevent player from moving during delay
                            awaiting_cpu = true;

                            // search for the best possible moves, return in sorted order
                            var dirs = my_board.explore_moves();
                            if (!dirs){
                                dirs = [[0, "up"],[ 0, "down"],[ 0, "left"],[ 0, "right"]]
                            }
                            var options = [], costs = [];
                            for (let idx = 0; idx < dirs.length; ++idx){
                                options.push(dirs[idx][1]);
                                costs.push(dirs[idx][0]);
                            }
                            console.log("options: " + options + "\, costs (negative of differential for player 2): " + costs);
                            
                            if (difficulty == "easy")
                                weight = [40, 30, 20, 10];
                            else if (difficulty == "medium")
                                weight = [60, 30, 5, 5];
                            else if (difficulty == "hard")
                                weight = [90, 5, 3, 2];
                            else if (difficulty == "impossible")
                                weight = [100, 0, 0, 0];
                            else
                                weight = [1, 1, 1, 1];

                            // cpu delay and move
                            // TODO: remove while (not doing anything), and move cpumove out of function : cpumove(options, weight)
                            function cpumove(){
                                move = selectrand(options, weight);
                                console.log("CPU moving in direction " + move + " with difficulty " + difficulty);
                                makeMove(move);
                                
                                // failsafe: try every direction if first fails
                                for (let idx = 0; idx < 4; ++idx){
                                    if (my_board.board_state != "no_change")
                                        break;
                                    move = options[idx];
                                    console.log("FAILSAFE: CPU moving in direction " + move + " with difficulty " + difficulty);
                                    makeMove(move);
                                }
                                } while (my_board.board_state == "no_change");

                                sleep(1500)
                                    .then(() => cpumove())
                                    .then(() => awaiting_cpu = false);
                            }
                    }
                    update_needed = false;
                }
            }
            
            resetBoard();
            // set initial colors:
            setColor("blue", 1);
            setColor("salmon", 2);
            setInterval(mainLoop, 10);
        </script>
    </body>
</html>
