<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="styles.css">
        <title>2048 Duel</title>
    </head>
    <body>
        <h1 id="title_field">2048 Duel!</h1>
        <canvas id="myCanvas" width="615" height="775" padding="20px"></canvas>
        <p class="game-intro">How to play: use the arrow keys to move all pieces in one of the 4 directions. When the same number move into each other, the
            pieces merge and double. If you merge one of your pieces with one of your opponents, you steal the piece. Take turns with your opponent, and try to be the first one to reach 64 or fill up the board with the 
            highest score. Have fun :)</p>
        
        <script>
            // document.write("hello world")
            // ----------------------- Settings and Setup -----------------------
            var canvas = document.getElementById("myCanvas");
            var ctx = canvas.getContext("2d");
            
            var size = 150

            // fonts
            block_font = "75px Standard";
            block_font2 = "75px Palatino";
            block_font3 = "75px Helvetica Neue";
            

            score_font = "30px Palatino";
            turn_font = "50px Palatino";


            // colors
            var green = "121, 130, 101";
            var salmon = "203, 141, 126";
            var navy = "33, 51, 67";
            var yellow = "231,185,28"
            
            var black = "67,67,67";
            var grey = "147,152,157";
            var white = "250,250,250";
            var cream = "250,249,243";

            // settings for player 1 and 2 colors
            var p1color = green;
            var p2color = salmon;

            var rightPressed = false;
            var leftPressed = false;
            var upPressed = false;
            var downPressed = false;
            var resetPressed = false;

            // board information
            board_info = null;
            var keypress_active = false;
            var update_needed = false;
            var move_type = null;
            var endgame = false;

            // holds the http request object
            var xhr = null;

            // ------------------------------------------------------------------

            // --------------------------- Game Logic ---------------------------
            class Board {
                constructor(win_condition=64) {
                    // board variables
                    this.board_size = 4;
                    this.win_condition = win_condition;
                    this.squares_added = 1;
                    this.board_state = "continue";  // "continue", "no_change", "win1", "win2", "loss"
                    this.player = 0;
                    this.first_round = true;

                    // create board
                    this.board = new Array(this.board_size);
                    for (let r = 0; r < this.board.length; ++r){
                        this.board[r] = new Array(this.board_size).fill(0);
                    }
                    this.owner = new Array(this.board_size);
                    for (let r = 0; r < this.owner.length; ++r){
                        this.owner[r] = new Array(this.board_size).fill(-1);
                    }

                    // initialize the first numbers
                    var st1 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]
                    var st2 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]
                    while (st1[0] == st2[0] || st1[1] == st2[1])
                        st2 = [randint(0, this.board_size - 1), randint(0, this.board_size - 1)]

                    this.board[st1[0]][st1[1]] = 2
                    this.owner[st1[0]][st1[1]] = 0

                    this.board[st2[0]][st2[1]] = 2
                    this.owner[st2[0]][st2[1]] = 1


                    this.p1score = 2;
                    this.p2score = 2;
                }

                move(dir){
                    prev_state = deepCopy(this.board);

                    if (dir == "up")
                        this.up();
                    else if (dir == "down")
                        this.down();
                    else if (dir == "left")
                        this.left();
                    else if (dir == "right")
                        this.right();
                    else{
                        console.log("ERROR: invalid direction (" + dir + ")");
                        return;
                    }

                    // check for no change
                    if (deepCompare(this.board, prev_state)){
                        this.state = "no_change";
                        return;
                    }

                    // check for win condition and add squares
                    cands = new Array();
                    this.p1score = 0;
                    this.p2score = 0;
                    // DEBUG continue here

                }

                left(){
                    /* make a left movement */
                    for (let row = 0; row < this.board.length; ++row){
                        // store the new row
                        var newrow = Array(this.board.length).fill(0);
                        var newowner = Array(this.board.length).fill(-1);
                        var newidx = 0;

                        for (let col = 0; col < this.board[0].length; ++col){
                            if (this.board[row][col] != 0){

                                // merge
                                if (newidx > 0 && this.board[row][col] == newrow[newidx - 1]){
                                    newrow[newidx - 1] = newrow[newidx - 1] * -2; // negative prevents double merging

                                    // determine ownership of square
                                    if (newowner[newidx - 1] != this.owner[row][col]){
                                        newowner[newidx - 1] = this.player;
                                    }
                                }

                                // move without merging
                                else{
                                    newrow[newidx] = this.board[row][col];
                                    newowner[newidx] = this.owner[row][col];
                                    newidx += 1;
                                }
                            }
                        }

                        // update the board
                        for (let col = 0; col < this.board[0].length; ++col)
                            newrow[col] = Math.abs(newrow[col]);
                        this.board[row] = newrow;

                        // update the owner
                        this.owner[row] = newowner;
                    }
                }

                up(){
                    /* make an up movement */
                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    this.left();

                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);
                }

                right(){
                    /* make a right movement */
                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);

                    this.left();

                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);

                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);
                }

                down(){
                    /* make a downward movement */
                    this.board = rotateClock(this.board);
                    this.owner = rotateClock(this.owner);

                    this.left();

                    this.board = rotateCounter(this.board);
                    this.owner = rotateCounter(this.owner);
                }
            }

            // helper functions ---------------------------
            function randint(min, max){
                /* random number between min and max, inclusive */
                return Math.floor(Math.random() * (max - min + 1) ) + min;
            }

            const deepCopy = (arr) => {
                /* deep copy a multi-dimensional array */
                let copy = [];
                arr.forEach(elem => {
                    if(Array.isArray(elem)){
                    copy.push(deepCopy(elem))
                    }else{
                    if (typeof elem === 'object') {
                        copy.push(deepCopyObject(elem))
                    } else {
                        copy.push(elem)
                    }
                    }
                })
                return copy;
            }

            function deepCompare(arr1, arr2){
                /* determines equality between two arrays */
                if (arr1.length != arr2.length || arr1[0].length != arr2[0].length)
                    return false;

                for (let r = 0; r < arr1.length; ++r){
                    for (let c = 0; c < arr1[0].length; ++c){
                        if (arr1[r][c] != arr2[r][c])
                            return false;
                    }
                }

                return true;
            }

            function rotateCounter(arr){
                /* rotate a square array 90 degrees counterclockwise */
                newarr = deepCopy(arr);

                for (let row = 0; row < arr.length; ++row){
                    for (let col = 0; col < arr[0].length; ++col){
                        newarr[newarr.length - col - 1][row] = arr[row][col];
                    }
                }

                return newarr;
            }

            function rotateClock(arr){
                /* rotate a square array 90 degrees clockwise */
                newarr = deepCopy(arr);

                for (let row = 0; row < arr.length; ++row){
                    for (let col = 0; col < arr[0].length; ++col){
                        newarr[col][arr.length - row - 1] = arr[row][col];
                    }
                }

                return newarr
            }

            // debug
            var my_board = new Board(64);
            my_board.board = [
                [2, 2, 4, 0],
                [2, 2, 4, 4],
                [2, 2, 2, 4],
                [2, 2, 2, 4],
            ];
            my_board.owner = [
                [0, 0, 1, -1],
                [1, 1, 0, 1],
                [0, 1, 1, 1],
                [1, 0, 1, 1]
            ];
            console.log("before move, board: ");
            for (let r = 0; r < my_board.board.length; ++r)
                console.log(my_board.board[r]);
            console.log("before move, owner: ");
            for (let r = 0; r < my_board.owner.length; ++r)
                console.log(my_board.owner[r]);
            console.log("making move");


            my_board.right();
            console.log("after move, board: " +  my_board.board);
            for (let r = 0; r < my_board.board.length; ++r)
                console.log(my_board.board[r]);
            console.log("after move, owner: " + my_board.owner);
            for (let r = 0; r < my_board.owner.length; ++r)
                console.log(my_board.owner[r]);

            testarr = [
                [1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]
            ]
            rotatearr = rotateClock(testarr);

            // ------------------------------------------------------------------

            // --------------------- Listeners and Handlers ---------------------
            document.addEventListener("keydown", keyDownHandler, false);
            document.addEventListener("keyup", keyUpHandler, false);

            function keyDownHandler(e) {
                // prevent arrow keys from scrolling
                if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                    e.preventDefault();
                }   

                if(e.key == "Right" || e.key == "ArrowRight" || e.key == "d" || e.key == "KeyD") {
                    rightPressed = true;
                    move_type = "right";
                }
                else if(e.key == "Left" || e.key == "ArrowLeft" || e.key == "a" || e.key == "KeyA") {
                    leftPressed = true;
                    move_type = "left";
                }
                else if (e.key == "Up" || e.key == "ArrowUp" || e.key == "w" || e.key == "KeyW"){
                    upPressed = true;
                    move_type = "up";
                }
                else if (e.key == "Down" || e.key == "ArrowDown" || e.key == "s" || e.key == "KeyS"){
                    downPressed = true;
                    move_type = "down";
                }

                else if (e.key == "r" || e.key == "KeyR"){
                    resetPressed = true;
                }

                // set keypress active variable
                if (rightPressed || leftPressed || upPressed || downPressed || resetPressed){
                    if (!keypress_active){
                        keypress_active = true;
                        update_needed = true;
                    }
                }
            }

            function keyUpHandler(e) {
                if(e.key == "Right" || e.key == "ArrowRight" || e.key == "d" || e.key == "KeyD") {
                    rightPressed = false;
                }
                else if(e.key == "Left" || e.key == "ArrowLeft" || e.key == "a" || e.key == "KeyA") {
                    leftPressed = false;
                }
                else if (e.key == "Up" || e.key == "ArrowUp" || e.key == "w" || e.key == "KeyW"){
                    upPressed = false;
                }
                else if (e.key == "Down" || e.key == "ArrowDown" || e.key == "s" || e.key == "KeyS"){
                    downPressed = false;
                }
                else if (e.key == "r" || e.key == "KeyR"){
                    resetPressed = false;
                }

                if (!rightPressed && !leftPressed && !upPressed && !downPressed && !resetPressed){
                    if (keypress_active){
                        keypress_active = false;
                    }
                }
            }
            // ------------------------------------------------------------------
            
            // ------------------------ Backend Requests ------------------------
            // build the http request object
            getXmlHttpRequestObject = function () {
                if (!xhr) {
                    // Create a new XMLHttpRequest object 
                    xhr = new XMLHttpRequest();
                }
                return xhr;
            };

            // function to control getBoard response behavior
            function boardCallback() {
                // Check response is ready or not
                if (xhr.readyState == 4 && xhr.status == 200) {
                    console.log("User data received!");
                    
                    // Update board_info with new text
                    board_info = JSON.parse(xhr.responseText);

                    // debugging
                    // dataDiv = document.getElementById('board_printer');
                    // dataDiv.innerHTML = xhr.responseText;
                    console.log(xhr.responseText);

                    // check for endgame
                    if (board_info["state"] != "CONTINUE" && board_info["state"] != "NO_CHANGE"){
                        console.log("endgame reached");
                        endgame = true;
                    }

                    // update the screen
                    drawBoard(board_info);
                }
            }

            // Gets updated board information and updates the screen
            function updateBoard() {
                console.log("Getting board...");
                xhr = getXmlHttpRequestObject();
                xhr.onreadystatechange = boardCallback;

                // synchronous requests
                xhr.open("GET", "http://localhost:6969/board", true);

                // Send the request over the network
                xhr.send(null);
            }

            function makeMove(direction){
                xhr = getXmlHttpRequestObject();
                xhr.onreadystatechange = boardCallback;

                // synchronous request
                xhr.open("POST", "http://localhost:6969/move", true);
                xhr.setRequestHeader("Content-Type", "application/json");
                var data = JSON.stringify({"move" : direction});
                
                // Send the request over the network
                xhr.send(data);
            }

            function resetBoard(){
                xhr = getXmlHttpRequestObject();
                xhr.onreadystatechange = boardCallback;

                // synchronous request
                xhr.open("POST", "http://localhost:6969/reset", true);
                
                // Send the request over the network
                xhr.send(null);
            }

            // ------------------------------------------------------------------


            // draw the grid
            function drawBoard(board_info){
                // grab the updated board
                // clear the grid
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (!board_info){
                    console.log("error: no board information received");
                }
                for (var row = 0; row < 4; ++row){
                    for (var col = 0; col < 4; ++col){
                        ctx.beginPath();

                        text = "0";
                        owner = null;
                        player = -1;

                        // parse the current number
                        if (board_info != null){
                            console.log("board information recieved in drawGrid()")
                            text = board_info["board"][col][row].toString();                            
                            
                            // set the owner
                            if (text != 0){
                                if (board_info["owner"][col][row] == 0){
                                    player = 1;
                                }
                                else {
                                    player = 2;
                                }
                            }
                        }
                        
                        // draw the rectangle backgrounds
                        ctx.rect(size * row + .1 * size, size * col + .1 * size, .9 * size, .9 * size);
                        if (player == 1){
                            ctx.fillStyle = "rgb(" + p1color + ", 0.5)";
                        }
                        else if (player == 2){
                            ctx.fillStyle = "rgb(" + p2color + ", 0.5)";
                        }
                        else{
                            ctx.fillStyle = "rgb(" + grey + ", 0.25)";
                        }
                        ctx.fill();
                        
                        // draw the numbers
                        ctx.font = block_font3;
                        ctx.textAlign = "center";
                        if (text != "0"){
                            ctx.fillStyle = "rgba(" + white + ", 1)";
                            ctx.fillText(text, size * row + .55 * size, size * col + .675 * size);
                        }
                        
                        ctx.closePath();
                    }
                }

                // write the scores
                ctx.beginPath();
                // ctx.rect(.1 * size, 4 * size + .1 * size, 3.9 * size, size);
                // ctx.fillStyle = "rgb(" + white + ", 0.25)"
                // ctx.fill();

                ctx.font = score_font;
                ctx.textAlign = "left";
                ctx.fillStyle = "rgba(" + p1color + ", .5)";
                text = "Player 1 score: " + board_info["p1score"];
                ctx.fillText(text, .2 * size, 4 * size + .4 * size);

                ctx.textAlign = "right";
                ctx.fillStyle = "rgba(" + p2color + ", .5)";
                text = "Player 2 score: " + board_info["p2score"];
                ctx.fillText(text, canvas.width - .2 * size, 4 * size + .4 * size);
                
                // write the turn
                ctx.textAlign = "center";
                ctx.font = turn_font;

                // tie
                if (board_info["state"] == "LOSS"){
                    ctx.fillStyle = "rgba(" + grey + ", .5)";
                    text = "It's a tie!";
                }
                // win
                else if (board_info["state"] == "WIN1"){
                    console.log("player 1 won!");
                    ctx.fillStyle = "rgba(" + p1color + ", .5)";
                    text = "Player 1 wins!";
                }
                else if (board_info["state"] == "WIN2"){
                    ctx.fillStyle = "rgba(" + p2color + ", .5)";
                    text = "Player 2 wins!";
                }

                // normal
                else{
                    if (board_info["turn"] == 1){
                        ctx.fillStyle = "rgba(" + p1color + ", .5)";
                        if (board_info["state"] == "NO_CHANGE")
                            text = "No change, move again";
                        
                        else
                            text = "Player 1's turn";
                        
                    }
                    else{
                        ctx.fillStyle = "rgba(" + p2color + ", .5)";
                        if (board_info["state"] == "NO_CHANGE")
                            text = "No change, move again";
                        
                        else
                            text = "Player 2's turn";
                        
                    }
                }
                ctx.fillText(text, canvas.width / 2, 4 * size + .9 * size);

                
                ctx.closePath();
            }

            function mainLoop(){

                // process keypress
                if (update_needed){
                    if (resetPressed){
                        console.log("resetting");
                        resetBoard();
                        endgame = false;
                    }
                    else if (!endgame){
                        console.log("making move " + move_type);
                        makeMove(move_type);
                    }
                    update_needed = false;
                }

                // debugging
                // document.getElementById("debug1").innerHTML = "up: " + upPressed + ", down: " + downPressed;
                // document.getElementById("debug2").innerHTML = "left: " + leftPressed + ", right: " + rightPressed;
            }
            
            updateBoard();
            setInterval(mainLoop, 10);
        </script>
    </body>
</html>
